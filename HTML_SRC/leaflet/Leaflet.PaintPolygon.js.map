{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/polygon-clipping/dist/polygon-clipping.js","webpack:///./src/PaintPolygon.css?9718","webpack:///./src/PaintPolygon.css","webpack:///./node_modules/css-loader/lib/url/escape.js","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./src/PaintPolygon.svg","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./node_modules/turf/src/helpers/index.js","webpack:///./node_modules/turf/src/invariant/index.js","webpack:///./node_modules/turf/src/destination/index.js","webpack:///./node_modules/turf/src/circle/index.js","webpack:///./node_modules/turf/src/meta/index.js","webpack:///./src/myTurf.js","webpack:///./node_modules/turf/src/union/index.js","webpack:///./node_modules/turf/src/difference/index.js","webpack:///./src/PaintPolygon.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","factory","self","./main.js","eval","./node_modules/qheap/index.js","./node_modules/qheap/lib/qheap.js","./node_modules/splaytree/index.js","__webpack_exports__","./src/bbox.js","./src/clean-input.js","./src/flp.js","./src/geom-in.js","./src/geom-out.js","./src/index.js","./src/operation.js","./src/segment.js","./src/sweep-event.js","./src/sweep-line.js","./src/vector.js","content","options","hmr","transform","insertInto","undefined","locals","escape","push","url","test","slice","replace","useSourceMap","list","toString","this","map","item","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","sources","source","sourceRoot","concat","join","cssWithMappingToString","mediaQuery","alreadyImportedModules","length","id","fn","memo","stylesInDom","isOldIE","window","document","all","atob","apply","arguments","getElement","target","styleTarget","querySelector","HTMLIFrameElement","contentDocument","head","e","singleton","singletonCounter","stylesInsertedAtTop","fixUrls","addStylesToDom","styles","domStyle","refs","j","parts","addStyle","listToStyles","newStyles","base","part","css","media","insertStyleElement","style","Error","lastStyleElementInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","before","removeStyleElement","parentNode","removeChild","idx","indexOf","splice","createStyleElement","createElement","attrs","type","addAttrs","el","keys","forEach","setAttribute","obj","update","remove","result","styleIndex","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","link","rel","createLinkElement","autoFixUrls","convertToAbsoluteUrls","blob","oldSrc","href","styleSheet","cssText","createTextNode","newObj","DEBUG","newList","mayRemove","textStore","replaceText","index","replacement","filter","Boolean","cssNode","childNodes","location","baseUrl","protocol","host","currentDir","pathname","fullMatch","origUrl","newUrl","unquotedOrigUrl","trim","$1","factors","centimeters","earthRadius","centimetres","degrees","Math","PI","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","helpers_feature","geometry","properties","feat","checkIfOptionsExist","bbox","point","coordinates","polygon","ring","multiPolygon","lengthToRadians","distance","units","factor","radiansToDegrees","degreesToRadians","isObject","input","constructor","getGeom","geojson","destination","origin","bearing","coordinates1","coord","Array","isArray","getCoord","longitude1","latitude1","bearingRad","latitude2","asin","sin","cos","atan2","src_circle","center","radius","steps","geomEach","callback","g","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","features","geometries","myTurf","circle","union","fc","args","geom","contour","unioned","polygon_clipping","difference","polygon1","polygon2","geom1","geom2","differenced","PaintPolygon_PaintPolygon","L","Control","extend","position","minRadius","maxRadius","layerOptions","drawOptions","weight","eraseOptions","color","menu","drawErase","size","eraseAll","_latlng","_metersPerPixel","onAdd","_map","setRadius","DomUtil","_container","_createMenu","onRemove","off","_onMouseMove","_radius","_circle","startDraw","_action","_addMouseListener","circleMarker","addTo","startErase","_removeMouseListener","getLayer","_layer","setData","data","_data","geoJSON","getData","_iconDraw","_iconErase","DomEvent","on","_clickDraw","_clickErase","_iconSize","_menu","disableClickPropagation","menuContent","cursor","min","max","_cursorMove","_clickSize","_iconEraseAll","_clickEraseAll","evt","_resetMenu","_activeIconStyle","hasClass","_closeMenu","_openMenu","removeClass","icon","addClass","valueAsNumber","_onMouseDown","_onMouseUp","dragging","disable","_mousedown","enable","_setLatLng","latlng","_stackEvt","getZoom","setLatLng","_latLngAsGeoJSON","lng","lat","_getCircleAsPolygon","zoom","abs","pow","_draw","_erase","action","_stack","_processStack","_processingStack","shift","PaintPolygon","control","paintPolygon"],"mappings":"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","file":"Leaflet.PaintPolygon.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"polygon-clipping\"] = factory();\n\telse\n\t\troot[\"polygon-clipping\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./main.js\":\n/*!*****************!*\\\n  !*** ./main.js ***!\n  \\*****************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.difference = exports.xor = exports.intersection = exports.union = undefined;\\n\\nvar _src = __webpack_require__(/*! ./src */ \\\"./src/index.js\\\");\\n\\nvar _src2 = _interopRequireDefault(_src);\\n\\nvar _operation = __webpack_require__(/*! ./src/operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar union = exports.union = function union(geom) {\\n  for (var _len = arguments.length, moreGeoms = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    moreGeoms[_key - 1] = arguments[_key];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.UNION, geom, moreGeoms);\\n};\\n\\nvar intersection = exports.intersection = function intersection(geom) {\\n  for (var _len2 = arguments.length, moreGeoms = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n    moreGeoms[_key2 - 1] = arguments[_key2];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.INTERSECTION, geom, moreGeoms);\\n};\\n\\nvar xor = exports.xor = function xor(geom) {\\n  for (var _len3 = arguments.length, moreGeoms = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\\n    moreGeoms[_key3 - 1] = arguments[_key3];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.XOR, geom, moreGeoms);\\n};\\n\\nvar difference = exports.difference = function difference(subjectGeom) {\\n  for (var _len4 = arguments.length, clippingGeoms = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\\n    clippingGeoms[_key4 - 1] = arguments[_key4];\\n  }\\n\\n  return (0, _src2.default)(_operation2.default.types.DIFFERENCE, subjectGeom, clippingGeoms);\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./main.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/qheap/index.js\":\n/*!*************************************!*\\\n  !*** ./node_modules/qheap/index.js ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"module.exports = __webpack_require__(/*! ./lib/qheap.js */ \\\"./node_modules/qheap/lib/qheap.js\\\");\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/qheap/index.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/qheap/lib/qheap.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/qheap/lib/qheap.js ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"/**\\n * nodejs heap, classic array implementation\\n *\\n * Items are stored in a balanced binary tree packed into an array where\\n * node is at [i], left child is at [2*i], right at [2*i+1].  Root is at [1].\\n *\\n * Copyright (C) 2014-2017 Andras Radics\\n * Licensed under the Apache License, Version 2.0\\n */\\n\\n\\n\\nmodule.exports = Heap;\\n\\nfunction isBeforeDefault( a, b ) { return a < b; }\\n\\nfunction Heap( opts ) {\\n    opts = opts || {};\\n    if (typeof opts === 'function') opts = {compar: opts};\\n\\n    if (opts.compar) {\\n        this._isBefore = function(a, b) { return opts.compar(a,b) < 0 };\\n    } else if (opts.comparBefore) {\\n        this._isBefore = opts.comparBefore;\\n    } else {\\n        this._isBefore = isBeforeDefault;\\n    }\\n    this.length = 0;\\n    this._freeSpace = opts.freeSpace ? this._trimArraySize : false;\\n    this._list = new Array(opts.size || 100);\\n}\\n\\nHeap.prototype._list = null;\\nHeap.prototype._compar = null;\\nHeap.prototype._isBefore = null;\\nHeap.prototype._freeSpace = null;\\nHeap.prototype.length = 0;\\n\\n/*\\n * insert new item at end, and bubble up\\n */\\nHeap.prototype.insert = function Heap_insert( item ) {\\n    var idx = ++this.length;\\n    var list = this._list;\\n    list[idx] = item;\\n\\n    while (idx > 1) {\\n        var parentidx = idx >> 1;\\n        var parentval = list[parentidx];\\n        if (!(this._isBefore(item, parentval))) break;\\n        list[idx] = parentval;\\n        idx = parentidx;\\n    }\\n    list[idx] = item;\\n};\\nHeap.prototype.append = Heap.prototype.insert;\\nHeap.prototype.push = Heap.prototype.insert;\\nHeap.prototype.unshift = Heap.prototype.insert;\\nHeap.prototype.enqueue = Heap.prototype.insert;\\n\\nHeap.prototype.peek = function Heap_peek( ) {\\n    return this.length > 0 ? this._list[1] : undefined;\\n};\\n\\nHeap.prototype.size = function Heap_size( ) {\\n    return this.length;\\n};\\n\\n/*\\n * return the root, and bubble down last item from top root position\\n * when bubbling down, r: root idx, c: child sub-tree root idx, cv: child root value\\n * Note that the child at (c == this.length) does not have to be tested in the loop,\\n * since its value is the one being bubbled down, so can loop `while (c < len)`.\\n *\\n * Note that a redundant (c < len &&) test before the c vs c+1 compar lets node v0.10\\n * run 4x faster; v4, v5 and v6 run faster without it if using _isBefore and not\\n * raw _compar.\\n *\\n * Note that this version runs faster than the two-pass pull-up-new-root then\\n * bubble-up-last-value-from-hole approach (except when inserting pre-sorted data).\\n */\\nHeap.prototype.remove = function Heap_remove( ) {\\n    if (this.length < 1) return undefined;\\n    var ret = this._list[1];\\n    var itm = this._list[this.length];\\n\\n    var r = 1, c = 2, cv;\\n    var len = this.length;\\n    while (c < len) {\\n        cv = this._list[c];\\n        if (this._isBefore(this._list[c+1], cv)) { cv = this._list[c+1] ; c = c+1 }\\n        if (!(this._isBefore(cv, itm))) break;\\n        this._list[r] = cv;\\n        r = c;\\n        c = c << 1;\\n    }\\n    this._list[len] = 0;\\n    this.length = --len;\\n    if (len) this._list[r] = itm;\\n    if (this._freeSpace) this._freeSpace(this._list, len);\\n\\n    return ret;\\n};\\nHeap.prototype.shift = Heap.prototype.remove;\\nHeap.prototype.pop = Heap.prototype.remove;\\nHeap.prototype.dequeue = Heap.prototype.remove;\\n\\n/*\\n * Free unused storage slots in the _list.\\n * The default is to unconditionally gc, use the options to omit when not useful.\\n */\\nHeap.prototype.gc = function Heap_gc( options ) {\\n    if (!options) options = {};\\n\\n    var minListLength = options.minLength;      // smallest list that will be gc-d\\n    if (minListLength === undefined) minListLength = 0;\\n\\n    var minListFull = options.minFull;          // list utilization below which to gc\\n    if (minListFull === undefined) minListFull = 1.00;\\n\\n    if (this._list.length >= minListLength && (this.length < this._list.length * minListFull)) {\\n        // gc reallocates the array to free the unused storage slots at the end\\n        // use splice to actually free memory; 7% slower than setting .length\\n        // note: list.slice makes the array slower to insert to??  splice is better\\n        this._list.splice(this.length+1, this._list.length);\\n    }\\n}\\n\\nHeap.prototype._trimArraySize = function Heap__trimArraySize( list, len ) {\\n    if (len > 10000 && list.length > 4 * len) {\\n        // use slice to actually free memory; 7% slower than setting .length\\n        // note: list.slice makes the array slower to insert to??  splice is better\\n        list.splice(len+1, list.length);\\n    }\\n}\\n\\nHeap.prototype._check = function Heap__check( ) {\\n    var isBefore = this._isBefore;\\n    var _compar = function(a, b) { return isBefore(a, b) ? -1 : 1 };\\n\\n    var i, p, fail = 0;\\n    for (i=this.length; i>1; i--) {\\n        // error if parent should go after child, but not if don`t care\\n        p = i >>> 1;\\n        // swapping the values must change their ordering, otherwise the\\n        // comparison is a tie.  (Ie, consider the ordering func (a <= b)\\n        // that for some values reports both that a < b and b < a.)\\n        if (_compar(this._list[p], this._list[i]) > 0 &&\\n            _compar(this._list[i], this._list[p]) < 0)\\n        {\\n            fail = i;\\n        }\\n    }\\n    if (fail) console.log(\\\"failed at\\\", (fail >>> 1), fail);\\n    return !fail;\\n}\\n\\n// optimize access\\nHeap.prototype = Heap.prototype;\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/qheap/lib/qheap.js?\");\n\n/***/ }),\n\n/***/ \"./node_modules/splaytree/index.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/splaytree/index.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"default\\\", function() { return Tree; });\\n/* follows \\\"An implementation of top-down splaying\\\"\\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\\n */\\n\\n/**\\n * @typedef {*} Key\\n */\\n\\n\\n/**\\n * @typedef {*} Value\\n */\\n\\n\\n/**\\n * @typedef {function(node:Node):void} Visitor\\n */\\n\\n\\n/**\\n * @typedef {function(a:Key, b:Key):number} Comparator\\n */\\n\\n\\n/**\\n * @param {function(node:Node):string} NodePrinter\\n */\\n\\n\\n/**\\n * @typedef {Object}  Node\\n * @property {Key}    Key\\n * @property {Value=} data\\n * @property {Node}   left\\n * @property {Node}   right\\n */\\n\\nclass Node {\\n\\n  constructor (key, data) {\\n    this.key    = key;\\n    this.data   = data;\\n    this.left   = null;\\n    this.right  = null;\\n  }\\n}\\n\\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\\n\\n\\n/**\\n * Simple top down splay, not requiring i to be in the tree t.\\n * @param {Key} i\\n * @param {Node?} t\\n * @param {Comparator} comparator\\n */\\nfunction splay (i, t, comparator) {\\n  if (t === null) return t;\\n  let l, r, y;\\n  const N = new Node();\\n  l = r = N;\\n\\n  while (true) {\\n    const cmp = comparator(i, t.key);\\n    //if (i < t.key) {\\n    if (cmp < 0) {\\n      if (t.left === null) break;\\n      //if (i < t.left.key) {\\n      if (comparator(i, t.left.key) < 0) {\\n        y = t.left;                           /* rotate right */\\n        t.left = y.right;\\n        y.right = t;\\n        t = y;\\n        if (t.left === null) break;\\n      }\\n      r.left = t;                               /* link right */\\n      r = t;\\n      t = t.left;\\n    //} else if (i > t.key) {\\n    } else if (cmp > 0) {\\n      if (t.right === null) break;\\n      //if (i > t.right.key) {\\n      if (comparator(i, t.right.key) > 0) {\\n        y = t.right;                          /* rotate left */\\n        t.right = y.left;\\n        y.left = t;\\n        t = y;\\n        if (t.right === null) break;\\n      }\\n      l.right = t;                              /* link left */\\n      l = t;\\n      t = t.right;\\n    } else {\\n      break;\\n    }\\n  }\\n  /* assemble */\\n  l.right = t.left;\\n  r.left = t.right;\\n  t.left = N.right;\\n  t.right = N.left;\\n  return t;\\n}\\n\\n\\n/**\\n * @param  {Key}        i\\n * @param  {Value}      data\\n * @param  {Comparator} comparator\\n * @param  {Tree}       tree\\n * @return {Node}      root\\n */\\nfunction insert (i, data, t, comparator, tree) {\\n  const node = new Node(i, data);\\n\\n  tree._size++;\\n\\n  if (t === null) {\\n    node.left = node.right = null;\\n    return node;\\n  }\\n\\n  t = splay(i, t, comparator);\\n  const cmp = comparator(i, t.key);\\n  if (cmp < 0) {\\n    node.left = t.left;\\n    node.right = t;\\n    t.left = null;\\n  } else if (cmp >= 0) {\\n    node.right = t.right;\\n    node.left = t;\\n    t.right = null;\\n  }\\n  return node;\\n}\\n\\n\\n/**\\n * Insert i into the tree t, unless it's already there.\\n * @param  {Key}        i\\n * @param  {Value}      data\\n * @param  {Comparator} comparator\\n * @param  {Tree}       tree\\n * @return {Node}       root\\n */\\nfunction add (i, data, t, comparator, tree) {\\n  const node = new Node(i, data);\\n\\n  if (t === null) {\\n    node.left = node.right = null;\\n    tree._size++;\\n    return node;\\n  }\\n\\n  t = splay(i, t, comparator);\\n  const cmp = comparator(i, t.key);\\n  if (cmp === 0) return t;\\n  else {\\n    if (cmp < 0) {\\n      node.left = t.left;\\n      node.right = t;\\n      t.left = null;\\n    } else if (cmp > 0) {\\n      node.right = t.right;\\n      node.left = t;\\n      t.right = null;\\n    }\\n    tree._size++;\\n    return node;\\n  }\\n}\\n\\n\\n/**\\n * Deletes i from the tree if it's there\\n * @param {Key}        i\\n * @param {Tree}       tree\\n * @param {Comparator} comparator\\n * @param {Tree}       tree\\n * @return {Node}      new root\\n */\\nfunction remove (i, t, comparator, tree) {\\n  let x;\\n  if (t === null) return null;\\n  t = splay(i, t, comparator);\\n  if (i === t.key) {               /* found it */\\n    if (t.left === null) {\\n      x = t.right;\\n    } else {\\n      x = splay(i, t.left, comparator);\\n      x.right = t.right;\\n    }\\n    tree._size--;\\n    return x;\\n  }\\n  return t;                         /* It wasn't there */\\n}\\n\\n\\nfunction split (key, v, comparator) {\\n  let left, right;\\n  if (v === null) {\\n    left = right = null;\\n  } else {\\n    v = splay(key, v, comparator);\\n\\n    const cmp = comparator(v.key, key);\\n    if (cmp === 0) {\\n      left  = v.left;\\n      right = v.right;\\n    } else if (cmp < 0) {\\n      right   = v.right;\\n      v.right = null;\\n      left    = v;\\n    } else {\\n      left   = v.left;\\n      v.left = null;\\n      right  = v;\\n    }\\n  }\\n  return { left, right };\\n}\\n\\n\\nfunction merge (left, right, comparator) {\\n  if (right === null) return left;\\n  if (left  === null) return right;\\n\\n  right = splay(left.key, right, comparator);\\n  right.left = left;\\n  return right;\\n}\\n\\n\\n/**\\n * Prints level of the tree\\n * @param  {Node}                        root\\n * @param  {String}                      prefix\\n * @param  {Boolean}                     isTail\\n * @param  {Array<string>}               out\\n * @param  {Function(node:Node):String}  printNode\\n */\\nfunction printRow (root, prefix, isTail, out, printNode) {\\n  if (root) {\\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\\\n`);\\n    const indent = prefix + (isTail ? '    ' : '│   ');\\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\\n  }\\n}\\n\\n\\nclass Tree {\\n\\n  constructor (comparator = DEFAULT_COMPARE) {\\n    this._comparator = comparator;\\n    this._root = null;\\n    this._size = 0;\\n  }\\n\\n\\n  /**\\n   * Inserts a key, allows duplicates\\n   * @param  {Key}    key\\n   * @param  {Value=} data\\n   * @return {Node|null}\\n   */\\n  insert (key, data) {\\n    return this._root = insert(key, data, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * Adds a key, if it is not present in the tree\\n   * @param  {Key}    key\\n   * @param  {Value=} data\\n   * @return {Node|null}\\n   */\\n  add (key, data) {\\n    return this._root = add(key, data, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  remove (key) {\\n    this._root = remove(key, this._root, this._comparator, this);\\n  }\\n\\n\\n  /**\\n   * Removes and returns the node with smallest key\\n   * @return {?Node}\\n   */\\n  pop () {\\n    let node = this._root;\\n    if (node) {\\n      while (node.left) node = node.left;\\n      this._root = splay(node.key,  this._root, this._comparator);\\n      this._root = remove(node.key, this._root, this._comparator, this);\\n      return { key: node.key, data: node.data };\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  findStatic (key) {\\n    let current   = this._root;\\n    const compare = this._comparator;\\n    while (current) {\\n      const cmp = compare(key, current.key);\\n      if (cmp === 0)    return current;\\n      else if (cmp < 0) current = current.left;\\n      else              current = current.right;\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Node|null}\\n   */\\n  find (key) {\\n    if (this._root) {\\n      this._root = splay(key, this._root, this._comparator);\\n      if (this._comparator(key, this._root.key) !== 0) return null;\\n    }\\n    return this._root;\\n  }\\n\\n\\n  /**\\n   * @param  {Key} key\\n   * @return {Boolean}\\n   */\\n  contains (key) {\\n    let current   = this._root;\\n    const compare = this._comparator;\\n    while (current) {\\n      const cmp = compare(key, current.key);\\n      if (cmp === 0)    return true;\\n      else if (cmp < 0) current = current.left;\\n      else              current = current.right;\\n    }\\n    return false;\\n  }\\n\\n\\n  /**\\n   * @param  {Visitor} visitor\\n   * @param  {*=}      ctx\\n   * @return {SplayTree}\\n   */\\n  forEach (visitor, ctx) {\\n    let current = this._root;\\n    const Q = [];  /* Initialize stack s */\\n    let done = false;\\n\\n    while (!done) {\\n      if (current !==  null) {\\n        Q.push(current);\\n        current = current.left;\\n      } else {\\n        if (Q.length !== 0) {\\n          current = Q.pop();\\n          visitor.call(ctx, current);\\n\\n          current = current.right;\\n        } else done = true;\\n      }\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\\n   * @param  {Key}      low\\n   * @param  {Key}      high\\n   * @param  {Function} fn\\n   * @param  {*?}       ctx\\n   * @return {SplayTree}\\n   */\\n  range (low, high, fn, ctx) {\\n    const Q = [];\\n    const compare = this._comparator;\\n    let node = this._root, cmp;\\n\\n    while (Q.length !== 0 || node) {\\n      if (node) {\\n        Q.push(node);\\n        node = node.left;\\n      } else {\\n        node = Q.pop();\\n        cmp = compare(node.key, high);\\n        if (cmp > 0) {\\n          break;\\n        } else if (compare(node.key, low) >= 0) {\\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\\n        }\\n        node = node.right;\\n      }\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * Returns array of keys\\n   * @return {Array<Key>}\\n   */\\n  keys () {\\n    const keys = [];\\n    this.forEach(({ key }) => keys.push(key));\\n    return keys;\\n  }\\n\\n\\n  /**\\n   * Returns array of all the data in the nodes\\n   * @return {Array<Value>}\\n   */\\n  values () {\\n    const values = [];\\n    this.forEach(({ data }) => values.push(data));\\n    return values;\\n  }\\n\\n\\n  /**\\n   * @return {Key|null}\\n   */\\n  min() {\\n    if (this._root) return this.minNode(this._root).key;\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @return {Key|null}\\n   */\\n  max() {\\n    if (this._root) return this.maxNode(this._root).key;\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @return {Node|null}\\n   */\\n  minNode(t = this._root) {\\n    if (t) while (t.left) t = t.left;\\n    return t;\\n  }\\n\\n\\n  /**\\n   * @return {Node|null}\\n   */\\n  maxNode(t = this._root) {\\n    if (t) while (t.right) t = t.right;\\n    return t;\\n  }\\n\\n\\n  /**\\n   * Returns node at given index\\n   * @param  {number} index\\n   * @return {?Node}\\n   */\\n  at (index) {\\n    let current = this._root, done = false, i = 0;\\n    const Q = [];\\n\\n    while (!done) {\\n      if (current) {\\n        Q.push(current);\\n        current = current.left;\\n      } else {\\n        if (Q.length > 0) {\\n          current = Q.pop();\\n          if (i === index) return current;\\n          i++;\\n          current = current.right;\\n        } else done = true;\\n      }\\n    }\\n    return null;\\n  }\\n\\n\\n  /**\\n   * @param  {Node}   d\\n   * @return {Node|null}\\n   */\\n  next (d) {\\n    let root = this._root;\\n    let successor = null;\\n\\n    if (d.right) {\\n      successor = d.right;\\n      while (successor.left) successor = successor.left;\\n      return successor;\\n    }\\n\\n    const comparator = this._comparator;\\n    while (root) {\\n      const cmp = comparator(d.key, root.key);\\n      if (cmp === 0) break;\\n      else if (cmp < 0) {\\n        successor = root;\\n        root = root.left;\\n      } else root = root.right;\\n    }\\n\\n    return successor;\\n  }\\n\\n\\n  /**\\n   * @param  {Node} d\\n   * @return {Node|null}\\n   */\\n  prev (d) {\\n    let root = this._root;\\n    let predecessor = null;\\n\\n    if (d.left !== null) {\\n      predecessor = d.left;\\n      while (predecessor.right) predecessor = predecessor.right;\\n      return predecessor;\\n    }\\n\\n    const comparator = this._comparator;\\n    while (root) {\\n      const cmp = comparator(d.key, root.key);\\n      if (cmp === 0) break;\\n      else if (cmp < 0) root = root.left;\\n      else {\\n        predecessor = root;\\n        root = root.right;\\n      }\\n    }\\n    return predecessor;\\n  }\\n\\n\\n  /**\\n   * @return {SplayTree}\\n   */\\n  clear() {\\n    this._root = null;\\n    this._size = 0;\\n    return this;\\n  }\\n\\n\\n  /**\\n   * @return {NodeList}\\n   */\\n  toList() {\\n    return toList(this._root);\\n  }\\n\\n\\n  /**\\n   * Bulk-load items. Both array have to be same size\\n   * @param  {Array<Key>}    keys\\n   * @param  {Array<Value>}  [values]\\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\\n   *                                         tree's comparator. Sorting is done\\n   *                                         in-place\\n   * @return {AVLTree}\\n   */\\n  load (keys = [], values = [], presort = false) {\\n    let size = keys.length;\\n    const comparator = this._comparator;\\n\\n    // sort if needed\\n    if (presort) sort(keys, values, 0, size - 1, comparator);\\n\\n    if (this._root === null) { // empty tree\\n      this._root = loadRecursive(this._root, keys, values, 0, size);\\n      this._size = size;\\n    } else { // that re-builds the whole tree from two in-order traversals\\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\\n      size = this._size + size;\\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\\n    }\\n    return this;\\n  }\\n\\n\\n  /**\\n   * @return {Boolean}\\n   */\\n  isEmpty() { return this._root === null; }\\n\\n  get size () { return this._size; }\\n\\n\\n  /**\\n   * @param  {NodePrinter=} printNode\\n   * @return {String}\\n   */\\n  toString (printNode = (n) => n.key) {\\n    const out = [];\\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\\n    return out.join('');\\n  }\\n\\n\\n  update (key, newKey, newData) {\\n    const comparator = this._comparator;\\n    let { left, right } = split(key, this._root, comparator);\\n    this._size--;\\n    if (comparator(key, newKey) < 0) {\\n      right = insert(newKey, newData, right, comparator, this);\\n    } else {\\n      left = insert(newKey, newData, left, comparator, this);\\n    }\\n    this._root = merge(left, right, comparator);\\n  }\\n\\n\\n  split(key) {\\n    return split(key, this._root, this._comparator);\\n  }\\n}\\n\\n\\nfunction loadRecursive (parent, keys, values, start, end) {\\n  const size = end - start;\\n  if (size > 0) {\\n    const middle = start + Math.floor(size / 2);\\n    const key    = keys[middle];\\n    const data   = values[middle];\\n    const node   = { key, data, parent };\\n    node.left    = loadRecursive(node, keys, values, start, middle);\\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\\n    return node;\\n  }\\n  return null;\\n}\\n\\n\\nfunction createList(keys, values) {\\n  const head = { next: null };\\n  let p = head;\\n  for (let i = 0; i < keys.length; i++) {\\n    p = p.next = { key: keys[i], data: values[i] };\\n  }\\n  p.next = null;\\n  return head.next;\\n}\\n\\n\\nfunction toList (root) {\\n  var current = root;\\n  var Q = [], done = false;\\n\\n  const head = { next: null };\\n  let p = head;\\n\\n  while (!done) {\\n    if (current) {\\n      Q.push(current);\\n      current = current.left;\\n    } else {\\n      if (Q.length > 0) {\\n        current = p = p.next = Q.pop();\\n        current = current.right;\\n      } else done = true;\\n    }\\n  }\\n  p.next = null; // that'll work even if the tree was empty\\n  return head.next;\\n}\\n\\n\\nfunction sortedListToBST(list, start, end) {\\n  const size = end - start;\\n  if (size > 0) {\\n    const middle = start + Math.floor(size / 2);\\n    const left = sortedListToBST(list, start, middle);\\n\\n    const root = list.head;\\n    root.left = left;\\n\\n    list.head = list.head.next;\\n\\n    root.right = sortedListToBST(list, middle + 1, end);\\n    return root;\\n  }\\n  return null;\\n}\\n\\n\\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\\n  const head = {}; // dummy\\n  let p = head;\\n\\n  let p1 = l1;\\n  let p2 = l2;\\n\\n  while (p1 !== null && p2 !== null) {\\n    if (compare(p1.key, p2.key) < 0) {\\n      p.next = p1;\\n      p1 = p1.next;\\n    } else {\\n      p.next = p2;\\n      p2 = p2.next;\\n    }\\n    p = p.next;\\n  }\\n\\n  if (p1 !== null)      p.next = p1;\\n  else if (p2 !== null) p.next = p2;\\n\\n  return head.next;\\n}\\n\\n\\nfunction sort(keys, values, left, right, compare) {\\n  if (left >= right) return;\\n\\n  const pivot = keys[(left + right) >> 1];\\n  let i = left - 1;\\n  let j = right + 1;\\n\\n  while (true) {\\n    do i++; while (compare(keys[i], pivot) < 0);\\n    do j--; while (compare(keys[j], pivot) > 0);\\n    if (i >= j) break;\\n\\n    let tmp = keys[i];\\n    keys[i] = keys[j];\\n    keys[j] = tmp;\\n\\n    tmp = values[i];\\n    values[i] = values[j];\\n    values[j] = tmp;\\n  }\\n\\n  sort(keys, values,  left,     j, compare);\\n  sort(keys, values, j + 1, right, compare);\\n}\\n\\n\\n//# sourceURL=webpack://polygon-clipping/./node_modules/splaytree/index.js?\");\n\n/***/ }),\n\n/***/ \"./src/bbox.js\":\n/*!*********************!*\\\n  !*** ./src/bbox.js ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getUniqueCorners = exports.getBboxOverlap = exports.doBboxesOverlap = exports.isInBbox = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\n/**\\n * A bounding box has the format:\\n *\\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\\n *\\n */\\n\\nvar isInBbox = exports.isInBbox = function isInBbox(bbox, point) {\\n  var xmin = bbox.ll.x;\\n  var ymin = bbox.ll.y;\\n  var xmax = bbox.ur.x;\\n  var ymax = bbox.ur.y;\\n  var xpt = point.x;\\n  var ypt = point.y;\\n  return (0, _flp.cmp)(xmin, xpt) <= 0 && (0, _flp.cmp)(xpt, xmax) <= 0 && (0, _flp.cmp)(ymin, ypt) <= 0 && (0, _flp.cmp)(ypt, ymax) <= 0;\\n};\\n\\nvar doBboxesOverlap = exports.doBboxesOverlap = function doBboxesOverlap(b1, b2) {\\n  return !((0, _flp.cmp)(b2.ur.x, b1.ll.x) < 0 || (0, _flp.cmp)(b1.ur.x, b2.ll.x) < 0 || (0, _flp.cmp)(b2.ur.y, b1.ll.y) < 0 || (0, _flp.cmp)(b1.ur.y, b2.ll.y) < 0);\\n};\\n\\n/* Returns either null, or a bbox (aka an ordered pair of points)\\n * If there is only one point of overlap, a bbox with identical points\\n * will be returned */\\nvar getBboxOverlap = exports.getBboxOverlap = function getBboxOverlap(b1, b2) {\\n  if (!doBboxesOverlap(b1, b2)) return null;\\n\\n  // find the middle two X values\\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\\n\\n  // find the middle two Y values\\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\\n\\n  // put those middle values together to get the overlap\\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };\\n};\\n\\n/* Returns a list of unique corners.\\n * Will contain one, two or four points */\\nvar getUniqueCorners = exports.getUniqueCorners = function getUniqueCorners(bbox) {\\n  var xmin = bbox.ll.x;\\n  var ymin = bbox.ll.y;\\n  var xmax = bbox.ur.x;\\n  var ymax = bbox.ur.y;\\n  var xEq = (0, _flp.cmp)(xmin, xmax) === 0;\\n  var yEq = (0, _flp.cmp)(ymin, ymax) === 0;\\n  if (xEq && yEq) return [{ x: xmin, y: ymin }];\\n  if (xEq) return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }];\\n  if (yEq) return [{ x: xmin, y: ymin }, { x: xmax, y: ymin }];\\n  return [{ x: xmin, y: ymin }, { x: xmin, y: ymax }, { x: xmax, y: ymin }, { x: xmax, y: ymax }];\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/bbox.js?\");\n\n/***/ }),\n\n/***/ \"./src/clean-input.js\":\n/*!****************************!*\\\n  !*** ./src/clean-input.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.errorOnSelfIntersectingRings = exports.cleanRing = exports.cleanMultiPoly = exports.forceMultiPoly = exports.pointsAsObjects = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\n/* Given input geometry as a standard array-of-arrays geojson-style\\n * geometry, return one that uses objects as points, for better perf */\\nvar pointsAsObjects = exports.pointsAsObjects = function pointsAsObjects(geom) {\\n  // we can handle well-formed multipolys and polys\\n  var output = [];\\n  if (!Array.isArray(geom)) {\\n    throw new Error('Input is not a Polygon or MultiPolygon');\\n  }\\n  for (var i = 0, iMax = geom.length; i < iMax; i++) {\\n    if (!Array.isArray(geom[i])) {\\n      throw new Error('Input is not a Polygon or MultiPolygon');\\n    }\\n    output.push([]);\\n    for (var j = 0, jMax = geom[i].length; j < jMax; j++) {\\n      if (!Array.isArray(geom[i][j])) {\\n        throw new Error('Input is not a Polygon or MultiPolygon');\\n      }\\n      if (geom[i][j].length === 2) {\\n        output[i].push({ x: geom[i][j][0], y: geom[i][j][1] });\\n        continue;\\n      }\\n      output[i].push([]);\\n      for (var k = 0, kMax = geom[i][j].length; k < kMax; k++) {\\n        if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length !== 2) {\\n          throw new Error('Input is not a Polygon or MultiPolygon');\\n        }\\n        output[i][j].push({ x: geom[i][j][k][0], y: geom[i][j][k][1] });\\n      }\\n    }\\n  }\\n  return output;\\n};\\n\\n/* WARN: input modified directly */\\nvar forceMultiPoly = exports.forceMultiPoly = function forceMultiPoly(geom) {\\n  if (Array.isArray(geom)) {\\n    if (geom.length === 0) return; // allow empty multipolys\\n\\n    if (Array.isArray(geom[0])) {\\n      if (Array.isArray(geom[0][0])) {\\n        if (typeof geom[0][0][0].x === 'number' && typeof geom[0][0][0].y === 'number') {\\n          // multipolygon\\n          return;\\n        }\\n      }\\n      if (typeof geom[0][0].x === 'number' && typeof geom[0][0].y === 'number') {\\n        // polygon\\n        geom.unshift(geom.splice(0));\\n        return;\\n      }\\n    }\\n  }\\n  throw new Error('Unrecognized input - not a polygon nor multipolygon');\\n};\\n\\n/* WARN: input modified directly */\\nvar cleanMultiPoly = exports.cleanMultiPoly = function cleanMultiPoly(multipoly) {\\n  var i = 0;\\n  while (i < multipoly.length) {\\n    var poly = multipoly[i];\\n    if (poly.length === 0) {\\n      multipoly.splice(i, 1);\\n      continue;\\n    }\\n\\n    var exteriorRing = poly[0];\\n    cleanRing(exteriorRing);\\n    // poly is dropped if exteriorRing is degenerate\\n    if (exteriorRing.length === 0) {\\n      multipoly.splice(i, 1);\\n      continue;\\n    }\\n\\n    var j = 1;\\n    while (j < poly.length) {\\n      var interiorRing = poly[j];\\n      cleanRing(interiorRing);\\n      if (interiorRing.length === 0) poly.splice(j, 1);else j++;\\n    }\\n\\n    i++;\\n  }\\n};\\n\\n/* Clean ring:\\n *  - remove duplicate points\\n *  - remove colinear points\\n *  - remove rings with no area (less than 3 distinct points)\\n *  - close rings (last point should equal first)\\n *\\n * WARN: input modified directly */\\nvar cleanRing = exports.cleanRing = function cleanRing(ring) {\\n  if (ring.length === 0) return;\\n  if ((0, _flp.cmpPoints)(ring[0], ring[ring.length - 1]) !== 0) {\\n    ring.push({ x: ring[0].x, y: ring[0].y }); // copy by value\\n  }\\n\\n  var isPointUncessary = function isPointUncessary(prevPt, pt, nextPt) {\\n    return (0, _flp.cmpPoints)(prevPt, pt) === 0 || (0, _flp.cmpPoints)(pt, nextPt) === 0 || (0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0;\\n  };\\n\\n  var i = 1;\\n  while (i < ring.length - 1) {\\n    if (isPointUncessary(ring[i - 1], ring[i], ring[i + 1])) ring.splice(i, 1);else i++;\\n  }\\n\\n  // check the first/last point as well\\n  while (ring.length > 2) {\\n    if (!isPointUncessary(ring[ring.length - 2], ring[0], ring[1])) break;\\n    ring.splice(0, 1);\\n    ring.splice(ring.length - 1, 1);\\n    ring.push(ring[0]);\\n  }\\n\\n  // if our ring has less than 3 distinct points now (so is degenerate)\\n  // shrink it down to the empty array to communicate to our caller to\\n  // drop it\\n  while (ring.length < 4 && ring.length > 0) {\\n    ring.pop();\\n  }\\n};\\n\\n/* Scan the already-linked events of the segments for any\\n * self-intersecting input rings (which are not supported) */\\nvar errorOnSelfIntersectingRings = exports.errorOnSelfIntersectingRings = function errorOnSelfIntersectingRings(segments) {\\n  var _loop = function _loop(i, iMax) {\\n    var seg = segments[i];\\n\\n    var evt = seg.flowIntoSE;\\n\\n    if (evt.linkedEvents.length > 2) {\\n      var evtsThisRing = evt.linkedEvents.filter(function (other) {\\n        return other.segment.ringIn === seg.ringIn;\\n      });\\n      if (evtsThisRing.length > 2) {\\n        evtsThisRing.sort(evt.getLeftmostComparator(evt.otherSE));\\n        var leftMostEvt = evtsThisRing[1]; // skip ourself\\n        var rightMostEvt = evtsThisRing[evtsThisRing.length - 1];\\n\\n        // both the segment on our immediate left and right will flow\\n        // 'out' in intersection point was a touch and not a crossing\\n        if (leftMostEvt.segment.flowIntoSE === leftMostEvt || rightMostEvt.segment.flowIntoSE === rightMostEvt) {\\n          throw new Error('Self-intersecting, crossing input ring found at ' + ('[' + evt.point.x + ', ' + evt.point.y + ']'));\\n        }\\n      }\\n    }\\n  };\\n\\n  for (var i = 0, iMax = segments.length; i < iMax; i++) {\\n    _loop(i, iMax);\\n  }\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/clean-input.js?\");\n\n/***/ }),\n\n/***/ \"./src/flp.js\":\n/*!********************!*\\\n  !*** ./src/flp.js ***!\n  \\********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n/* Javascript doesn't do integer math. Everything is\\n * floating point with percision Number.EPSILON.\\n *\\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\\n */\\n\\n// IE Polyfill\\nif (Number.EPSILON === undefined) Number.EPSILON = Math.pow(2, -52);\\n\\nvar EPSILON_SQ = Number.EPSILON * Number.EPSILON;\\n\\n/* FLP comparator */\\nvar cmp = exports.cmp = function cmp(a, b) {\\n  // check if they're both 0\\n  if (-Number.EPSILON < a && a < Number.EPSILON) {\\n    if (-Number.EPSILON < b && b < Number.EPSILON) {\\n      return 0;\\n    }\\n  }\\n\\n  // check if they're flp equal\\n  if ((a - b) * (a - b) < EPSILON_SQ * a * b) {\\n    return 0;\\n  }\\n\\n  // normal comparison\\n  return a < b ? -1 : 1;\\n};\\n\\n/* FLP point comparator, favors point encountered first by sweep line */\\nvar cmpPoints = exports.cmpPoints = function cmpPoints(aPt, bPt) {\\n  // fist compare X, then compare Y\\n\\n  var a = aPt.x;\\n  var b = bPt.x;\\n\\n  // inlined version of cmp() for performance boost\\n  if (a <= -Number.EPSILON || Number.EPSILON <= a || b <= -Number.EPSILON || Number.EPSILON <= b) {\\n    var diff = a - b;\\n    if (diff * diff >= EPSILON_SQ * a * b) {\\n      return a < b ? -1 : 1;\\n    }\\n  }\\n\\n  a = aPt.y;\\n  b = bPt.y;\\n\\n  // inlined version of cmp() for performance boost\\n  if (a <= -Number.EPSILON || Number.EPSILON <= a || b <= -Number.EPSILON || Number.EPSILON <= b) {\\n    var _diff = a - b;\\n    if (_diff * _diff >= EPSILON_SQ * a * b) {\\n      return a < b ? -1 : 1;\\n    }\\n  }\\n\\n  // they're the same\\n  return 0;\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/flp.js?\");\n\n/***/ }),\n\n/***/ \"./src/geom-in.js\":\n/*!************************!*\\\n  !*** ./src/geom-in.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MultiPoly = exports.Poly = exports.Ring = undefined;\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _segment = __webpack_require__(/*! ./segment */ \\\"./src/segment.js\\\");\\n\\nvar _segment2 = _interopRequireDefault(_segment);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n// Give rings unique ID's to get consistent sorting of segments\\n// and sweep events when all else is identical\\nvar ringId = 0;\\n\\nvar Ring = exports.Ring = function () {\\n  function Ring(geomRing, poly) {\\n    _classCallCheck(this, Ring);\\n\\n    this.id = ringId++;\\n    this.poly = poly;\\n    this.segments = [];\\n\\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\\n      this.segments.push(new _segment2.default(geomRing[i - 1], geomRing[i], this));\\n    }\\n  }\\n\\n  _createClass(Ring, [{\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = [];\\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\\n        var segment = this.segments[i];\\n        sweepEvents.push(segment.leftSE);\\n        sweepEvents.push(segment.rightSE);\\n      }\\n      return sweepEvents;\\n    }\\n  }, {\\n    key: 'isValid',\\n\\n\\n    /* Given a segment on this rings with these relationships to other rings,\\n     * is it a valid segment of the ring's poly? */\\n    value: function isValid(ringsSameSLER, ringsDiffSLER, ringsInsideOf) {\\n      var exterior = this.poly.exteriorRing;\\n      var interiors = this.poly.interiorRings;\\n\\n      if (this === exterior) {\\n        // exterior segments inside or interior, nope\\n        for (var i = 0, iMax = ringsInsideOf.length; i < iMax; i++) {\\n          if (interiors.includes(ringsInsideOf[i])) return false;\\n        }\\n\\n        // overlap with an interior of same SWL orientatio, nope\\n        for (var _i = 0, _iMax = ringsSameSLER.length; _i < _iMax; _i++) {\\n          if (interiors.includes(ringsSameSLER[_i])) return false;\\n        }\\n\\n        return true;\\n      }\\n\\n      // interior rings that aren't inside the exterior nor\\n      // overlapping with different SWE\\n      if (!ringsInsideOf.includes(exterior)) {\\n        if (!ringsDiffSLER.includes(exterior)) return false;\\n      }\\n\\n      // interior rings inside another interior, nope\\n      for (var _i2 = 0, _iMax2 = ringsInsideOf.length; _i2 < _iMax2; _i2++) {\\n        if (interiors.includes(ringsInsideOf[_i2])) return false;\\n      }\\n\\n      // overlapping interiors with different sweep line orientation, nope\\n      for (var _i3 = 0, _iMax3 = ringsDiffSLER.length; _i3 < _iMax3; _i3++) {\\n        if (interiors.includes(ringsDiffSLER[_i3])) return false;\\n      }\\n\\n      return true;\\n    }\\n  }, {\\n    key: 'isExterior',\\n    get: function get() {\\n      return this.poly.exteriorRing === this;\\n    }\\n  }, {\\n    key: 'isInterior',\\n    get: function get() {\\n      return this.poly.exteriorRing !== this;\\n    }\\n  }]);\\n\\n  return Ring;\\n}();\\n\\nvar Poly = exports.Poly = function () {\\n  function Poly(geomPoly, multiPoly) {\\n    _classCallCheck(this, Poly);\\n\\n    this.exteriorRing = new Ring(geomPoly[0], this);\\n    this.interiorRings = [];\\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\\n      this.interiorRings.push(new Ring(geomPoly[i], this));\\n    }\\n    this.multiPoly = multiPoly;\\n  }\\n\\n  _createClass(Poly, [{\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = this.exteriorRing.getSweepEvents();\\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\\n          sweepEvents.push(ringSweepEvents[j]);\\n        }\\n      }\\n      return sweepEvents;\\n    }\\n\\n    /* Given a segment with these rings, is that segment inside this polygon? */\\n\\n  }, {\\n    key: 'isInside',\\n    value: function isInside(ringsOnEdgeOf, ringsInsideOf) {\\n      // if we're on an edge, we can't be inside\\n      for (var i = 0, iMax = ringsOnEdgeOf.length; i < iMax; i++) {\\n        if (ringsOnEdgeOf[i].poly === this) return false;\\n      }\\n\\n      // we need to be inside the exterior, and nothing else\\n      var isInsideExterior = false;\\n      for (var _i4 = 0, _iMax4 = ringsInsideOf.length; _i4 < _iMax4; _i4++) {\\n        var ring = ringsInsideOf[_i4];\\n        if (ring.poly !== this) continue;\\n        if (ring.isInterior) return false;\\n        isInsideExterior = true;\\n      }\\n      return isInsideExterior;\\n    }\\n  }]);\\n\\n  return Poly;\\n}();\\n\\nvar MultiPoly = exports.MultiPoly = function () {\\n  function MultiPoly(geomMultiPoly) {\\n    _classCallCheck(this, MultiPoly);\\n\\n    this.polys = [];\\n    for (var i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\\n      this.polys.push(new Poly(geomMultiPoly[i], this));\\n    }\\n    this.isSubject = false;\\n  }\\n\\n  _createClass(MultiPoly, [{\\n    key: 'markAsSubject',\\n    value: function markAsSubject() {\\n      this.isSubject = true;\\n    }\\n  }, {\\n    key: 'getSweepEvents',\\n    value: function getSweepEvents() {\\n      var sweepEvents = [];\\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\\n        var polySweepEvents = this.polys[i].getSweepEvents();\\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\\n          sweepEvents.push(polySweepEvents[j]);\\n        }\\n      }\\n      return sweepEvents;\\n    }\\n  }]);\\n\\n  return MultiPoly;\\n}();\\n\\n//# sourceURL=webpack://polygon-clipping/./src/geom-in.js?\");\n\n/***/ }),\n\n/***/ \"./src/geom-out.js\":\n/*!*************************!*\\\n  !*** ./src/geom-out.js ***!\n  \\*************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.MultiPoly = exports.Poly = exports.Ring = undefined;\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Ring = exports.Ring = function () {\\n  _createClass(Ring, null, [{\\n    key: 'factory',\\n\\n    /* Given the segments from the sweep line pass, compute & return a series\\n     * of closed rings from all the segments marked to be part of the result */\\n    value: function factory(allSegments) {\\n      var ringsOut = [];\\n\\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\\n        var segment = allSegments[i];\\n        if (!segment.isInResult || segment.ringOut) continue;\\n\\n        var prevEvent = null;\\n        var event = segment.leftSE;\\n        var nextEvent = segment.rightSE;\\n        var events = [event];\\n\\n        var startingLE = event.linkedEvents;\\n        var intersectionLEs = [];\\n\\n        /* Walk the chain of linked events to form a closed ring */\\n        while (true) {\\n          prevEvent = event;\\n          event = nextEvent;\\n          events.push(event);\\n\\n          /* Is the ring complete? */\\n          if (event.linkedEvents === startingLE) break;\\n\\n          while (true) {\\n            var availableLEs = event.getAvailableLinkedEvents();\\n\\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\\n             * part of the algorithm malfunctioned... please file a bug report. */\\n            if (availableLEs.length === 0) {\\n              var firstPt = events[0].point;\\n              var lastPt = events[events.length - 1].point;\\n              throw new Error('Unable to complete output ring starting at [' + firstPt.x + ',' + (' ' + firstPt.y + ']. Last matching segment found ends at ') + (' [' + lastPt.x + ', ' + lastPt.y + '].'));\\n            }\\n\\n            /* Only one way to go, so cotinue on the path */\\n            if (availableLEs.length === 1) {\\n              nextEvent = availableLEs[0].otherSE;\\n              break;\\n            }\\n\\n            /* We must have an intersection. Check for a completed loop */\\n            var indexLE = null;\\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\\n              if (intersectionLEs[j].linkedEvents === event.linkedEvents) {\\n                indexLE = j;\\n                break;\\n              }\\n            }\\n            /* Found a completed loop. Cut that off and make a ring */\\n            if (indexLE !== null) {\\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\\n              var ringEvents = events.splice(intersectionLE.index);\\n              ringEvents.unshift(ringEvents[0].otherSE);\\n              ringsOut.push(new Ring(ringEvents.reverse()));\\n              continue;\\n            }\\n            /* register the intersection */\\n            intersectionLEs.push({\\n              index: events.length,\\n              linkedEvents: event.linkedEvents\\n            });\\n            /* Choose the left-most option to continue the walk */\\n            var comparator = event.getLeftmostComparator(prevEvent);\\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\\n            break;\\n          }\\n        }\\n\\n        ringsOut.push(new Ring(events));\\n      }\\n      return ringsOut;\\n    }\\n  }]);\\n\\n  function Ring(events) {\\n    _classCallCheck(this, Ring);\\n\\n    this.events = events;\\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\\n      events[i].segment.registerRingOut(this);\\n    }\\n    this.poly = null;\\n    this._clearCache();\\n  }\\n\\n  _createClass(Ring, [{\\n    key: 'registerPoly',\\n    value: function registerPoly(poly) {\\n      this.poly = poly;\\n    }\\n  }, {\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      // Remove superfluous points (ie extra points along a straight line),\\n      var points = [[this.events[0].point.x, this.events[0].point.y]];\\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\\n        var _prevPt = this.events[i - 1].point;\\n        var _pt = this.events[i].point;\\n        var _nextPt = this.events[i + 1].point;\\n        if ((0, _vector.compareVectorAngles)(_pt, _prevPt, _nextPt) === 0) continue;\\n        points.push([_pt.x, _pt.y]);\\n      }\\n\\n      // check if the starting point is necessary\\n      var prevPt = this.events[this.events.length - 2].point;\\n      var pt = this.events[0].point;\\n      var nextPt = this.events[1].point;\\n      if ((0, _vector.compareVectorAngles)(pt, prevPt, nextPt) === 0) points.shift();\\n\\n      // ring was all (within rounding error of angle calc) colinear points\\n      if (points.length === 0) return null;\\n\\n      points.push(points[0]);\\n      return this.isExteriorRing ? points : points.reverse();\\n    }\\n  }, {\\n    key: '_clearCache',\\n    value: function _clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: '_getCached',\\n    value: function _getCached(propName, calcMethod) {\\n      // if this._cache[something] isn't set, fill it with this._something()\\n      if (this._cache[propName] === undefined) {\\n        this._cache[propName] = this['_' + propName].bind(this)();\\n      }\\n      return this._cache[propName];\\n    }\\n  }, {\\n    key: '_isExteriorRing',\\n    value: function _isExteriorRing() {\\n      if (!this.enclosingRing) return true;\\n      if (!this.enclosingRing.enclosingRing) return false;\\n      // an island in hole is a whole new polygon\\n      return this.enclosingRing.enclosingRing.isExteriorRing;\\n    }\\n\\n    /* Returns the ring that encloses this one, if any */\\n\\n  }, {\\n    key: '_enclosingRing',\\n    value: function _enclosingRing() {\\n      var prevSeg = this.events[0].segment.prevInResult;\\n      while (prevSeg && prevSeg.ringOut === this) {\\n        prevSeg = prevSeg.prevInResult;\\n      }var prevPrevSeg = prevSeg ? prevSeg.prevInResult : null;\\n\\n      while (true) {\\n        // no segment found, thus no ring can enclose us\\n        if (!prevSeg) return null;\\n\\n        // no segments below prev segment found, thus the ring of the prev\\n        // segment must loop back around and enclose us\\n        if (!prevPrevSeg) return prevSeg.ringOut;\\n\\n        // if the two segments are of different rings, the ring of the prev\\n        // segment must either loop around us or the ring of the prev prev\\n        // seg, which would make us and the ring of the prev peers\\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\\n          if (prevPrevSeg.ringOut.enclosingRing !== prevSeg.ringOut) {\\n            return prevSeg.ringOut;\\n          } else return prevSeg.ringOut.enclosingRing;\\n        }\\n\\n        // two segments are from the same ring, so this was a penisula\\n        // of that ring. iterate downward, keep searching\\n        prevSeg = prevPrevSeg.prevInResult;\\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult : null;\\n      }\\n    }\\n  }, {\\n    key: 'enclosingRing',\\n    get: function get() {\\n      return this._getCached('enclosingRing');\\n    }\\n  }, {\\n    key: 'isExteriorRing',\\n    get: function get() {\\n      return this._getCached('isExteriorRing');\\n    }\\n  }]);\\n\\n  return Ring;\\n}();\\n\\nvar Poly = exports.Poly = function () {\\n  function Poly(exteriorRing) {\\n    _classCallCheck(this, Poly);\\n\\n    this.exteriorRing = exteriorRing;\\n    exteriorRing.registerPoly(this);\\n    this.interiorRings = [];\\n  }\\n\\n  _createClass(Poly, [{\\n    key: 'addInterior',\\n    value: function addInterior(ring) {\\n      this.interiorRings.push(ring);\\n      ring.registerPoly(this);\\n    }\\n  }, {\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      var geom = [this.exteriorRing.getGeom()];\\n      // exterior ring was all (within rounding error of angle calc) colinear points\\n      if (geom[0] === null) return null;\\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\\n        var ringGeom = this.interiorRings[i].getGeom();\\n        // interior ring was all (within rounding error of angle calc) colinear points\\n        if (ringGeom === null) continue;\\n        geom.push(ringGeom);\\n      }\\n      return geom;\\n    }\\n  }]);\\n\\n  return Poly;\\n}();\\n\\nvar MultiPoly = exports.MultiPoly = function () {\\n  function MultiPoly(rings) {\\n    _classCallCheck(this, MultiPoly);\\n\\n    this.rings = rings;\\n    this.polys = this._composePolys(rings);\\n  }\\n\\n  _createClass(MultiPoly, [{\\n    key: 'getGeom',\\n    value: function getGeom() {\\n      var geom = [];\\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\\n        var polyGeom = this.polys[i].getGeom();\\n        // exterior ring was all (within rounding error of angle calc) colinear points\\n        if (polyGeom === null) continue;\\n        geom.push(polyGeom);\\n      }\\n      return geom;\\n    }\\n  }, {\\n    key: '_composePolys',\\n    value: function _composePolys(rings) {\\n      var polys = [];\\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\\n        var ring = rings[i];\\n        if (ring.poly) continue;\\n        if (ring.isExteriorRing) polys.push(new Poly(ring));else {\\n          if (!ring.enclosingRing.poly) polys.push(new Poly(ring.enclosingRing));\\n          ring.enclosingRing.poly.addInterior(ring);\\n        }\\n      }\\n      return polys;\\n    }\\n  }]);\\n\\n  return MultiPoly;\\n}();\\n\\n//# sourceURL=webpack://polygon-clipping/./src/geom-out.js?\");\n\n/***/ }),\n\n/***/ \"./src/index.js\":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = doIt;\\n\\nvar _qheap = __webpack_require__(/*! qheap */ \\\"./node_modules/qheap/index.js\\\");\\n\\nvar _qheap2 = _interopRequireDefault(_qheap);\\n\\nvar _cleanInput = __webpack_require__(/*! ./clean-input.js */ \\\"./src/clean-input.js\\\");\\n\\nvar cleanInput = _interopRequireWildcard(_cleanInput);\\n\\nvar _geomIn = __webpack_require__(/*! ./geom-in */ \\\"./src/geom-in.js\\\");\\n\\nvar geomIn = _interopRequireWildcard(_geomIn);\\n\\nvar _geomOut = __webpack_require__(/*! ./geom-out */ \\\"./src/geom-out.js\\\");\\n\\nvar geomOut = _interopRequireWildcard(_geomOut);\\n\\nvar _operation = __webpack_require__(/*! ./operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \\\"./src/sweep-event.js\\\");\\n\\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\\n\\nvar _sweepLine = __webpack_require__(/*! ./sweep-line */ \\\"./src/sweep-line.js\\\");\\n\\nvar _sweepLine2 = _interopRequireDefault(_sweepLine);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction doIt(operationType, geom, moreGeoms) {\\n  /* Make a copy of the input geometry with points as objects, for perf */\\n  var geoms = [cleanInput.pointsAsObjects(geom)];\\n  for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\\n    geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]));\\n  }\\n\\n  /* Clean inputs */\\n  for (var _i = 0, _iMax = geoms.length; _i < _iMax; _i++) {\\n    cleanInput.forceMultiPoly(geoms[_i]);\\n    cleanInput.cleanMultiPoly(geoms[_i]);\\n  }\\n\\n  /* Convert inputs to MultiPoly objects, mark subject & register operation */\\n  var multipolys = [];\\n  for (var _i2 = 0, _iMax2 = geoms.length; _i2 < _iMax2; _i2++) {\\n    multipolys.push(new geomIn.MultiPoly(geoms[_i2]));\\n  }\\n  multipolys[0].markAsSubject();\\n  _operation2.default.register(operationType, multipolys.length);\\n\\n  /* Put segment endpoints in a priority queue */\\n  var queue = new _qheap2.default({ comparBefore: _sweepEvent2.default.compareBefore });\\n  for (var _i3 = 0, _iMax3 = multipolys.length; _i3 < _iMax3; _i3++) {\\n    var sweepEvents = multipolys[_i3].getSweepEvents();\\n    for (var j = 0, jMax = sweepEvents.length; j < jMax; j++) {\\n      queue.insert(sweepEvents[j]);\\n    }\\n  }\\n\\n  /* Pass the sweep line over those endpoints */\\n  var sweepLine = new _sweepLine2.default();\\n  while (queue.length) {\\n    var newEvents = sweepLine.process(queue.remove());\\n    for (var _i4 = 0, _iMax4 = newEvents.length; _i4 < _iMax4; _i4++) {\\n      queue.insert(newEvents[_i4]);\\n    }\\n  }\\n\\n  /* Error on self-crossing input rings */\\n  cleanInput.errorOnSelfIntersectingRings(sweepLine.segments);\\n\\n  /* Collect and compile segments we're keeping into a multipolygon */\\n  var ringsOut = geomOut.Ring.factory(sweepLine.segments);\\n  var result = new geomOut.MultiPoly(ringsOut);\\n  return result.getGeom();\\n}\\n\\n//# sourceURL=webpack://polygon-clipping/./src/index.js?\");\n\n/***/ }),\n\n/***/ \"./src/operation.js\":\n/*!**************************!*\\\n  !*** ./src/operation.js ***!\n  \\**************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Operation = function () {\\n  function Operation() {\\n    _classCallCheck(this, Operation);\\n\\n    this.types = {\\n      INTERSECTION: 0,\\n      UNION: 1,\\n      XOR: 2,\\n      DIFFERENCE: 3\\n    };\\n  }\\n\\n  _createClass(Operation, [{\\n    key: \\\"register\\\",\\n    value: function register(type, numMultiPolys) {\\n      this.type = type;\\n      this.numMultiPolys = numMultiPolys;\\n    }\\n  }]);\\n\\n  return Operation;\\n}();\\n\\n// global to register details about the operation on\\n\\n\\nvar operation = new Operation();\\n\\nexports.default = operation;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/operation.js?\");\n\n/***/ }),\n\n/***/ \"./src/segment.js\":\n/*!************************!*\\\n  !*** ./src/segment.js ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _operation = __webpack_require__(/*! ./operation */ \\\"./src/operation.js\\\");\\n\\nvar _operation2 = _interopRequireDefault(_operation);\\n\\nvar _sweepEvent = __webpack_require__(/*! ./sweep-event */ \\\"./src/sweep-event.js\\\");\\n\\nvar _sweepEvent2 = _interopRequireDefault(_sweepEvent);\\n\\nvar _bbox = __webpack_require__(/*! ./bbox */ \\\"./src/bbox.js\\\");\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar Segment = function () {\\n  _createClass(Segment, null, [{\\n    key: 'compare',\\n    value: function compare(a, b) {\\n      if (a === b) return 0;\\n\\n      var alx = a.leftSE.point.x;\\n      var aly = a.leftSE.point.y;\\n      var blx = b.leftSE.point.x;\\n      var bly = b.leftSE.point.y;\\n      var arx = a.rightSE.point.x;\\n      var brx = b.rightSE.point.x;\\n\\n      // check if they're even in the same vertical plane\\n      if ((0, _flp.cmp)(brx, alx) < 0) return 1;\\n      if ((0, _flp.cmp)(arx, blx) < 0) return -1;\\n\\n      var cmpLeft = a.comparePoint(b.leftSE.point);\\n      var cmpLX = (0, _flp.cmp)(alx, blx);\\n\\n      // are a and b colinear?\\n      if (cmpLeft === 0 && a.comparePoint(b.rightSE.point) === 0 && b.comparePoint(a.leftSE.point) === 0 && b.comparePoint(a.rightSE.point) === 0) {\\n        // colinear segments with non-matching left-endpoints, consider\\n        // the more-left endpoint to be earlier\\n        if (cmpLX !== 0) return cmpLX;\\n\\n        // colinear segments with matching left-endpoints, fall back\\n        // on creation order of segments as a tie-breaker\\n        // NOTE: we do not use segment length to break a tie here, because\\n        //       when segments are split their length changes\\n        if (a.ringIn.id !== b.ringIn.id) {\\n          return a.ringIn.id < b.ringIn.id ? -1 : 1;\\n        }\\n      } else {\\n        // not colinear\\n\\n        // if the our left endpoints are not in the same vertical line,\\n        // consider a vertical line at the rightmore of the two left endpoints,\\n        // consider the segment that intersects lower with that line to be earlier\\n        if (cmpLX < 0) return cmpLeft === 1 ? -1 : 1;\\n        if (cmpLX > 0) return b.comparePoint(a.leftSE.point) === 1 ? 1 : -1;\\n\\n        // if our left endpoints match, consider the segment\\n        // that angles more downward to be earlier\\n        if (cmpLX === 0 && (0, _flp.cmp)(a.leftSE.point.y, b.leftSE.point.y) === 0) {\\n          return a.comparePoint(b.rightSE.point) > 0 ? -1 : 1;\\n        }\\n\\n        // left endpoints are in the same vertical line but don't overlap exactly,\\n        // lower means ealier\\n        return (0, _flp.cmp)(aly, bly);\\n      }\\n\\n      throw new Error('Segment comparison (from [' + a.leftSE.point.x + ', ' + a.leftSR.point.y + '])' + (' -> to [' + a.rightSE.point.x + ', ' + a.rightSE.point.y + ']) failed... ') + ' segments equal but not identical?');\\n    }\\n  }]);\\n\\n  function Segment(point1, point2, ring) {\\n    _classCallCheck(this, Segment);\\n\\n    this.ringIn = ring;\\n    this.ringOut = null;\\n\\n    var ptCmp = (0, _flp.cmpPoints)(point1, point2);\\n    var lp = void 0;\\n    var rp = void 0;\\n    if (ptCmp < 0) {\\n      lp = point1;\\n      rp = point2;\\n      this.flowL2R = true;\\n    } else if (ptCmp > 0) {\\n      lp = point2;\\n      rp = point1;\\n      this.flowL2R = false;\\n    } else {\\n      throw new Error('Tried to create degenerate segment at [' + point1.x + ', ' + point1.y + ']');\\n    }\\n\\n    this.leftSE = new _sweepEvent2.default(lp, this);\\n    this.rightSE = new _sweepEvent2.default(rp, this);\\n\\n    // cache of dynamically computed properies\\n    this._clearCache();\\n  }\\n\\n  _createClass(Segment, [{\\n    key: 'clone',\\n    value: function clone() {\\n      var seg = new Segment(this.leftSE.point, this.rightSE.point, this.ringIn);\\n      seg.flowL2R = this.flowL2R;\\n      return seg;\\n    }\\n  }, {\\n    key: 'getOtherSE',\\n    value: function getOtherSE(se) {\\n      if (se === this.leftSE) return this.rightSE;\\n      if (se === this.rightSE) return this.leftSE;\\n      throw new Error('may only be called by own sweep events');\\n    }\\n  }, {\\n    key: 'isAnEndpoint',\\n    value: function isAnEndpoint(point) {\\n      return (0, _flp.cmpPoints)(point, this.leftSE.point) === 0 || (0, _flp.cmpPoints)(point, this.rightSE.point) === 0;\\n    }\\n  }, {\\n    key: 'isPointOn',\\n    value: function isPointOn(point) {\\n      return (0, _bbox.isInBbox)(this.bbox, point) && this.comparePoint(point) === 0;\\n    }\\n\\n    /* Compare this segment with a point. Return value indicates\\n     *    1: point is below segment\\n     *    0: point is colinear to segment\\n     *   -1: point is above segment */\\n\\n  }, {\\n    key: 'comparePoint',\\n    value: function comparePoint(point) {\\n      if (this.isAnEndpoint(point)) return 0;\\n      return (0, _vector.compareVectorAngles)(point, this.leftSE.point, this.rightSE.point);\\n    }\\n\\n    /**\\n     * Given another segment, returns an array of intersection points\\n     * between the two segments. The returned array can contain:\\n     *  * zero points:  no intersection b/t segments\\n     *  * one point:    segments intersect once\\n     *  * two points:   segments overlap. Endpoints of overlap returned.\\n     *                  Will be ordered as sweep line would encounter them.\\n     */\\n\\n  }, {\\n    key: 'getIntersections',\\n    value: function getIntersections(other) {\\n      // If bboxes don't overlap, there can't be any intersections\\n      var bboxOverlap = (0, _bbox.getBboxOverlap)(this.bbox, other.bbox);\\n      if (bboxOverlap === null) return [];\\n\\n      // The general algorithim doesn't handle overlapping colinear segments.\\n      // Overlapping colinear segments, if present, will have intersections\\n      // of one pair of opposing corners of the bbox overlap. Thus we just\\n      // manually check those coordinates.\\n      //\\n      // Note this also handles the cases of a collapsed bbox (just one point)\\n      // and semi-collapsed bbox (a vertical or horizontal line) as well.\\n      //\\n      // In addition, in the case of a T-intersection, this ensures that the\\n      // interseciton returned matches exactly an endpoint - no rounding error.\\n      var intersections = [];\\n      var bboxCorners = (0, _bbox.getUniqueCorners)(bboxOverlap);\\n      for (var i = 0, iMax = bboxCorners.length; i < iMax; i++) {\\n        var point = bboxCorners[i];\\n        // test if this point is an intersection\\n        if (this.isAnEndpoint(point) && other.isPointOn(point) || other.isAnEndpoint(point) && this.isPointOn(point)) {\\n          intersections.push(point);\\n        }\\n      }\\n      if (intersections.length > 0) return intersections;\\n\\n      // General case for non-overlapping segments.\\n      // This algorithm is based on Schneider and Eberly.\\n      // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\\n      var al = this.leftSE.point;\\n      var bl = other.leftSE.point;\\n      var va = this.vector;\\n      var vb = other.vector;\\n      var ve = { x: bl.x - al.x, y: bl.y - al.y };\\n      var kross = (0, _vector.crossProduct)(va, vb);\\n\\n      // not on line segment a\\n      var s = (0, _vector.crossProduct)(ve, vb) / kross;\\n      if ((0, _flp.cmp)(s, 0) < 0 || (0, _flp.cmp)(1, s) < 0) return [];\\n\\n      var t = (0, _vector.crossProduct)(ve, va) / kross;\\n      if ((0, _flp.cmp)(t, 0) < 0 || (0, _flp.cmp)(1, t) < 0) return [];\\n\\n      // intersection is in a midpoint of both lines, let's average them and\\n      // bound the result by org bbox (otherwise leftSE and rightSE could swap)\\n      var x = (al.x + s * va.x + bl.x + t * vb.x) / 2;\\n      var y = (al.y + s * va.y + bl.y + t * vb.y) / 2;\\n      if (x < bboxOverlap.ll.x) x = bboxOverlap.ll.x;\\n      if (x > bboxOverlap.ur.x) x = bboxOverlap.ur.x;\\n      if (y < bboxOverlap.ll.y) y = bboxOverlap.ll.y;\\n      if (y > bboxOverlap.ur.y) y = bboxOverlap.ur.y;\\n      return [{ x: x, y: y }];\\n    }\\n\\n    /**\\n     * Split the given segment into multiple segments on the given points.\\n     *  * The existing segment will retain it's leftSE and a new rightSE will be\\n     *    generated for it.\\n     *  * A new segment will be generated which will adopt the original segment's\\n     *    rightSE, and a new leftSE will be generated for it.\\n     *  * If there are more than two points given to split on, new segments\\n     *    in the middle will be generated with new leftSE and rightSE's.\\n     *  * An array of the newly generated SweepEvents will be returned.\\n     */\\n\\n  }, {\\n    key: 'split',\\n    value: function split(points) {\\n      // sort them and unique-ify them\\n      points.sort(_flp.cmpPoints);\\n      points = points.filter(function (pt, i, pts) {\\n        return i === 0 || (0, _flp.cmpPoints)(pts[i - 1], pt) !== 0;\\n      });\\n\\n      for (var i = 0, iMax = points.length; i < iMax; i++) {\\n        var pt = points[i];\\n        if (this.isAnEndpoint(pt)) {\\n          throw new Error('Cannot split segment upon endpoint at [' + pt.x + ', ' + pt.y + ']');\\n        }\\n      }\\n\\n      var point = points.shift();\\n      var newSeg = this.clone();\\n      newSeg.leftSE = new _sweepEvent2.default(point, newSeg);\\n      newSeg.rightSE = this.rightSE;\\n      this.rightSE.segment = newSeg;\\n      this.rightSE = new _sweepEvent2.default(point, this);\\n      var newEvents = [this.rightSE, newSeg.leftSE];\\n\\n      if (points.length > 0) {\\n        var moreNewEvents = newSeg.split(points);\\n        for (var _i = 0, _iMax = moreNewEvents.length; _i < _iMax; _i++) {\\n          newEvents.push(moreNewEvents[_i]);\\n        }\\n      }\\n      return newEvents;\\n    }\\n  }, {\\n    key: 'registerPrev',\\n    value: function registerPrev(other) {\\n      this.prev = other;\\n      this._clearCache();\\n    }\\n  }, {\\n    key: 'registerRingOut',\\n    value: function registerRingOut(ring) {\\n      this.ringOut = ring;\\n    }\\n\\n    /* The first segment previous segment chain that is in the result */\\n\\n  }, {\\n    key: '_prevInResult',\\n    value: function _prevInResult() {\\n      var prev = this.prev;\\n      while (prev && !prev.isInResult) {\\n        prev = prev.prev;\\n      }return prev;\\n    }\\n\\n    /* The segments, including ourselves, for which we overlap perfectly */\\n\\n  }, {\\n    key: '_coincidents',\\n    value: function _coincidents() {\\n      // a coincident will have both left and right sweepEvents linked with us\\n      var coincidents = [];\\n      var leftLinkedEvents = this.leftSE.linkedEvents;\\n      var rightLinkedEvents = this.rightSE.linkedEvents;\\n      for (var i = 0, iMax = leftLinkedEvents.length; i < iMax; i++) {\\n        var leftSE = leftLinkedEvents[i];\\n        if (!leftSE.isLeft) continue;\\n        if (leftSE.segment.rightSE.linkedEvents !== rightLinkedEvents) continue;\\n        coincidents.push(leftSE.segment);\\n      }\\n\\n      if (coincidents.length > 0) {\\n        // put the 'winner' at the front\\n        // arbitary - winner is the one with lowest ringId\\n        coincidents.sort(function (a, b) {\\n          return a.ringIn.id - b.ringIn.id;\\n        });\\n\\n        // set this in all our coincident's caches so they don't have to calc it\\n        for (var _i2 = 0, _iMax2 = coincidents.length; _i2 < _iMax2; _i2++) {\\n          coincidents[_i2]._cache['coincidents'] = coincidents;\\n        }\\n      }\\n      return coincidents;\\n    }\\n  }, {\\n    key: '_prevNotCoincident',\\n    value: function _prevNotCoincident() {\\n      // iterating backwards from next to prev\\n      var next = this;\\n      var prev = this.prev;\\n      while (prev && next.coincidents === prev.coincidents) {\\n        next = prev;\\n        prev = prev.prev;\\n      }\\n      return prev;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, enter the ring? */\\n\\n  }, {\\n    key: '_sweepLineEntersRing',\\n    value: function _sweepLineEntersRing() {\\n      // opposite of previous segment on the same ring\\n      var prev = this.prevNotCoincident;\\n      while (prev) {\\n        for (var i = 0, iMax = prev.coincidents.length; i < iMax; i++) {\\n          var seg = prev.coincidents[i];\\n          if (seg.ringIn === this.ringIn) return !seg.sweepLineEntersRing;\\n        }\\n        prev = prev.prevNotCoincident;\\n      }\\n      return true;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, enter the polygon? */\\n\\n  }, {\\n    key: '_ringsInsideOf',\\n    value: function _ringsInsideOf() {\\n      if (!this.prev) return [];\\n\\n      // coincidents always share the same rings. Return same array to save mem\\n      if (this.coincidents === this.prev.coincidents) {\\n        return this.prev.ringsInsideOf;\\n      }\\n\\n      var rings = [];\\n      var prevRingsInsideOf = this.prev.ringsInsideOf;\\n      var prevRingsEntering = this.prev.getRingsEntering();\\n      var ringsExiting = this.getRingsExiting();\\n\\n      // rings our prev was inside of all count, except those we're exiting\\n      for (var i = 0, iMax = prevRingsInsideOf.length; i < iMax; i++) {\\n        var ring = prevRingsInsideOf[i];\\n        if (!ringsExiting.includes(ring)) rings.push(ring);\\n      }\\n\\n      // rings our prev was entering of all count, except those we're exiting\\n      for (var _i3 = 0, _iMax3 = prevRingsEntering.length; _i3 < _iMax3; _i3++) {\\n        var _ring = prevRingsEntering[_i3];\\n        if (!ringsExiting.includes(_ring)) rings.push(_ring);\\n      }\\n\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of */\\n\\n  }, {\\n    key: 'getRingsOnEdgeOf',\\n    value: function getRingsOnEdgeOf() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        rings.push(this.coincidents[i].ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of,\\n     * and for which the sweep line enters when intersecting there */\\n\\n  }, {\\n    key: 'getRingsEntering',\\n    value: function getRingsEntering() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var segment = this.coincidents[i];\\n        if (!segment.sweepLineEntersRing) continue;\\n        rings.push(segment.ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Array of input rings this segment is on boundary of,\\n     * and for which the sweep line exits when intersecting there */\\n\\n  }, {\\n    key: 'getRingsExiting',\\n    value: function getRingsExiting() {\\n      var rings = [];\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var segment = this.coincidents[i];\\n        if (segment.sweepLineEntersRing) continue;\\n        rings.push(segment.ringIn);\\n      }\\n      return rings;\\n    }\\n\\n    /* Is this segment valid on our own polygon? (ie not outside exterior ring) */\\n\\n  }, {\\n    key: '_isValidEdgeForPoly',\\n    value: function _isValidEdgeForPoly() {\\n      // SLER: sweep line entering orientation\\n      var sameSLER = void 0;\\n      var diffSLER = void 0;\\n      if (this.sweepLineEntersRing) {\\n        sameSLER = this.getRingsEntering();\\n        diffSLER = this.getRingsExiting();\\n      } else {\\n        diffSLER = this.getRingsEntering();\\n        sameSLER = this.getRingsExiting();\\n      }\\n      return this.ringIn.isValid(sameSLER, diffSLER, this.ringsInsideOf);\\n    }\\n\\n    /* Array of multipolys this segment is inside of */\\n\\n  }, {\\n    key: 'getMultiPolysInsideOf',\\n    value: function getMultiPolysInsideOf() {\\n      var mps = [];\\n      for (var i = 0, iMax = this.ringsInsideOf.length; i < iMax; i++) {\\n        var poly = this.ringsInsideOf[i].poly;\\n        if (mps.includes(poly.multiPoly)) continue;\\n        if (!poly.isInside(this.getRingsOnEdgeOf(), this.ringsInsideOf)) continue;\\n        mps.push(poly.multiPoly);\\n      }\\n      return mps;\\n    }\\n\\n    /* The multipolys on one side of us */\\n\\n  }, {\\n    key: 'getMultiPolysSLPEnters',\\n    value: function getMultiPolysSLPEnters(multiPolysInsideOf) {\\n      // start with the multipolys we're fully inside\\n      var mps = multiPolysInsideOf.slice();\\n      // add the multipolys we have the sweep line entering\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var seg = this.coincidents[i];\\n        if (!seg.sweepLineEntersPoly) continue;\\n        var mp = seg.ringIn.poly.multiPoly;\\n        if (!mps.includes(mp)) mps.push(mp);\\n      }\\n      return mps;\\n    }\\n\\n    /* The multipolys on the other side of us */\\n\\n  }, {\\n    key: 'getMultiPolysSLPExits',\\n    value: function getMultiPolysSLPExits(multiPolysInsideOf) {\\n      // start with the multipolys we're fully inside\\n      var mps = multiPolysInsideOf.slice();\\n      // add the multipolys we have the sweep line entering\\n      for (var i = 0, iMax = this.coincidents.length; i < iMax; i++) {\\n        var seg = this.coincidents[i];\\n        if (!seg.sweepLineExitsPoly) continue;\\n        var mp = seg.ringIn.poly.multiPoly;\\n        if (!mps.includes(mp)) mps.push(mp);\\n      }\\n      return mps;\\n    }\\n\\n    /* Is this segment part of the final result? */\\n\\n  }, {\\n    key: '_isInResult',\\n    value: function _isInResult() {\\n      // if it's not the coincidence winner, it's not in the resul\\n      if (this !== this.coincidents[0]) return false;\\n\\n      var multiPolysInsideOf = this.getMultiPolysInsideOf();\\n      var multiPolysSLPEnters = this.getMultiPolysSLPEnters(multiPolysInsideOf);\\n      var multiPolysSLPExits = this.getMultiPolysSLPExits(multiPolysInsideOf);\\n\\n      switch (_operation2.default.type) {\\n        case _operation2.default.types.UNION:\\n          // UNION - included iff:\\n          //  * On one side of us there is 0 poly interiors AND\\n          //  * On the other side there is 1 or more.\\n          var noEnters = multiPolysSLPEnters.length === 0;\\n          var noExits = multiPolysSLPExits.length === 0;\\n          return noEnters !== noExits;\\n\\n        case _operation2.default.types.INTERSECTION:\\n          // INTERSECTION - included iff:\\n          //  * on one side of us all multipolys are rep. with poly interiors AND\\n          //  * on the other side of us, not all multipolys are repsented\\n          //    with poly interiors\\n          var least = void 0;\\n          var most = void 0;\\n          if (multiPolysSLPEnters.length < multiPolysSLPExits.length) {\\n            least = multiPolysSLPEnters.length;\\n            most = multiPolysSLPExits.length;\\n          } else {\\n            least = multiPolysSLPExits.length;\\n            most = multiPolysSLPEnters.length;\\n          }\\n          return most === _operation2.default.numMultiPolys && least < most;\\n\\n        case _operation2.default.types.XOR:\\n          // XOR - included iff:\\n          //  * the difference between the number of multipolys represented\\n          //    with poly interiors on our two sides is an odd number\\n          var diff = Math.abs(multiPolysSLPEnters.length - multiPolysSLPExits.length);\\n          return diff % 2 === 1;\\n\\n        case _operation2.default.types.DIFFERENCE:\\n          // DIFFERENCE included iff:\\n          //  * on exactly one side, we have just the subject\\n          var isJustSubject = function isJustSubject(mps) {\\n            return mps.length === 1 && mps[0].isSubject;\\n          };\\n          return isJustSubject(multiPolysSLPEnters) !== isJustSubject(multiPolysSLPExits);\\n\\n        default:\\n          throw new Error('Unrecognized operation type found ' + _operation2.default.type);\\n      }\\n    }\\n  }, {\\n    key: '_clearCache',\\n    value: function _clearCache() {\\n      this._cache = {};\\n    }\\n  }, {\\n    key: 'bbox',\\n    get: function get() {\\n      var y1 = this.leftSE.point.y;\\n      var y2 = this.rightSE.point.y;\\n      return {\\n        ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\\n        ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\\n      };\\n    }\\n\\n    /* A vector from the left point to the right */\\n\\n  }, {\\n    key: 'vector',\\n    get: function get() {\\n      return {\\n        x: this.rightSE.point.x - this.leftSE.point.x,\\n        y: this.rightSE.point.y - this.leftSE.point.y\\n      };\\n    }\\n  }, {\\n    key: 'isVertical',\\n    get: function get() {\\n      return (0, _flp.cmp)(this.leftSE.point.x, this.rightSE.point.x) === 0;\\n    }\\n\\n    /* In the original ringIn, which event came second */\\n\\n  }, {\\n    key: 'flowIntoSE',\\n    get: function get() {\\n      return this.flowL2R ? this.rightSE : this.leftSE;\\n    }\\n  }, {\\n    key: 'prevInResult',\\n    get: function get() {\\n      var key = 'prevInResult';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'coincidents',\\n    get: function get() {\\n      var key = 'coincidents';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'prevNotCoincident',\\n    get: function get() {\\n      var key = 'prevNotCoincident';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'sweepLineEntersRing',\\n    get: function get() {\\n      var key = 'sweepLineEntersRing';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'sweepLineEntersPoly',\\n    get: function get() {\\n      if (!this.isValidEdgeForPoly) return false;\\n      return this.ringIn.isExterior === this.sweepLineEntersRing;\\n    }\\n\\n    /* Does the sweep line, when it intersects this segment, exit the polygon? */\\n\\n  }, {\\n    key: 'sweepLineExitsPoly',\\n    get: function get() {\\n      if (!this.isValidEdgeForPoly) return false;\\n      return this.ringIn.isExterior !== this.sweepLineEntersRing;\\n    }\\n\\n    /* Array of input rings this segment is inside of (not on boundary) */\\n\\n  }, {\\n    key: 'ringsInsideOf',\\n    get: function get() {\\n      var key = 'ringsInsideOf';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'isValidEdgeForPoly',\\n    get: function get() {\\n      var key = 'isValidEdgeForPoly';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }, {\\n    key: 'isInResult',\\n    get: function get() {\\n      var key = 'isInResult';\\n      if (this._cache[key] === undefined) this._cache[key] = this['_' + key]();\\n      return this._cache[key];\\n    }\\n  }]);\\n\\n  return Segment;\\n}();\\n\\nexports.default = Segment;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/segment.js?\");\n\n/***/ }),\n\n/***/ \"./src/sweep-event.js\":\n/*!****************************!*\\\n  !*** ./src/sweep-event.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _vector = __webpack_require__(/*! ./vector */ \\\"./src/vector.js\\\");\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar SweepEvent = function () {\\n  _createClass(SweepEvent, null, [{\\n    key: 'compareBefore',\\n    value: function compareBefore(a, b) {\\n      // favor event with a point that the sweep line hits first\\n      var cmpX = (0, _flp.cmp)(a.point.x, b.point.x);\\n      if (cmpX !== 0) return cmpX < 0;\\n\\n      var cmpY = (0, _flp.cmp)(a.point.y, b.point.y);\\n      if (cmpY !== 0) return cmpY < 0;\\n\\n      // favor right events over left\\n      if (a.isLeft !== b.isLeft) return !a.isLeft;\\n\\n      // favor events where the line segment is lower\\n      var pointSegCmp = a.segment.comparePoint(b.otherSE.point);\\n      if (pointSegCmp !== 0) return pointSegCmp > 0;\\n\\n      // as a tie-breaker, favor lower segment creation id\\n      var aId = a.segment.ringIn.id;\\n      var bId = b.segment.ringIn.id;\\n      if (aId !== bId) return aId < bId;\\n\\n      // NOTE:  We don't sort on segment length because that changes\\n      //        as segments are divided.\\n\\n      // they appear to be the same point... are they?\\n      if (a === b) return false;\\n\\n      throw new Error('SweepEvent comparison failed at [' + a.point.x + ', ' + a.point.y + ']... ' + 'equal but not identical?');\\n    }\\n  }]);\\n\\n  function SweepEvent(point, segment) {\\n    _classCallCheck(this, SweepEvent);\\n\\n    this.point = point;\\n    this.segment = segment;\\n    this.linkedEvents = [this];\\n  }\\n\\n  _createClass(SweepEvent, [{\\n    key: 'link',\\n    value: function link(other) {\\n      var otherLE = other.linkedEvents;\\n      for (var i = 0, iMax = otherLE.length; i < iMax; i++) {\\n        var evt = otherLE[i];\\n        this.linkedEvents.push(evt);\\n        evt.linkedEvents = this.linkedEvents;\\n      }\\n    }\\n  }, {\\n    key: 'getAvailableLinkedEvents',\\n    value: function getAvailableLinkedEvents() {\\n      var events = [];\\n      for (var i = 0, iMax = this.linkedEvents.length; i < iMax; i++) {\\n        var evt = this.linkedEvents[i];\\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult) {\\n          events.push(evt);\\n        }\\n      }\\n      return events;\\n    }\\n\\n    /**\\n     * Returns a comparator function for sorting linked events that will\\n     * favor the event that will give us the smallest left-side angle.\\n     * All ring construction starts as low as possible heading to the right,\\n     * so by always turning left as sharp as possible we'll get polygons\\n     * without uncessary loops & holes.\\n     *\\n     * The comparator function has a compute cache such that it avoids\\n     * re-computing already-computed values.\\n     */\\n\\n  }, {\\n    key: 'getLeftmostComparator',\\n    value: function getLeftmostComparator(baseEvent) {\\n      var _this = this;\\n\\n      var cache = new Map();\\n\\n      var fillCache = function fillCache(linkedEvent) {\\n        var nextEvent = linkedEvent.otherSE;\\n        cache.set(linkedEvent, {\\n          sine: (0, _vector.sineOfAngle)(_this.point, baseEvent.point, nextEvent.point),\\n          cosine: (0, _vector.cosineOfAngle)(_this.point, baseEvent.point, nextEvent.point)\\n        });\\n      };\\n\\n      return function (a, b) {\\n        if (!cache.has(a)) fillCache(a);\\n        if (!cache.has(b)) fillCache(b);\\n\\n        var _cache$get = cache.get(a),\\n            asine = _cache$get.sine,\\n            acosine = _cache$get.cosine;\\n\\n        var _cache$get2 = cache.get(b),\\n            bsine = _cache$get2.sine,\\n            bcosine = _cache$get2.cosine;\\n\\n        var cmpZeroASine = (0, _flp.cmp)(asine, 0);\\n        var cmpZeroBSine = (0, _flp.cmp)(bsine, 0);\\n\\n        if (cmpZeroASine >= 0 && cmpZeroBSine >= 0) return (0, _flp.cmp)(bcosine, acosine);\\n        if (cmpZeroASine < 0 && cmpZeroBSine < 0) return (0, _flp.cmp)(acosine, bcosine);\\n        return (0, _flp.cmp)(bsine, asine);\\n      };\\n    }\\n  }, {\\n    key: 'isLeft',\\n    get: function get() {\\n      return this === this.segment.leftSE;\\n    }\\n  }, {\\n    key: 'isRight',\\n    get: function get() {\\n      return this === this.segment.rightSE;\\n    }\\n  }, {\\n    key: 'otherSE',\\n    get: function get() {\\n      return this.segment.getOtherSE(this);\\n    }\\n  }]);\\n\\n  return SweepEvent;\\n}();\\n\\nexports.default = SweepEvent;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/sweep-event.js?\");\n\n/***/ }),\n\n/***/ \"./src/sweep-line.js\":\n/*!***************************!*\\\n  !*** ./src/sweep-line.js ***!\n  \\***************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nvar _splaytree = __webpack_require__(/*! splaytree */ \\\"./node_modules/splaytree/index.js\\\");\\n\\nvar _splaytree2 = _interopRequireDefault(_splaytree);\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\nvar _segment = __webpack_require__(/*! ./segment */ \\\"./src/segment.js\\\");\\n\\nvar _segment2 = _interopRequireDefault(_segment);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * NOTE:  We must be careful not to change any segments while\\n *        they are in the SplayTree. AFAIK, there's no way to tell\\n *        the tree to rebalance itself - thus before splitting\\n *        a segment that's in the tree, we remove it from the tree,\\n *        do the split, then re-insert it. (Even though splitting a\\n *        segment *shouldn't* change its correct position in the\\n *        sweep line tree, the reality is because of rounding errors,\\n *        it sometimes does.)\\n */\\n\\nvar SweepLine = function () {\\n  function SweepLine() {\\n    var comparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _segment2.default.compare;\\n\\n    _classCallCheck(this, SweepLine);\\n\\n    this.tree = new _splaytree2.default(comparator);\\n    this.segments = [];\\n    this.prevEvent = null;\\n  }\\n\\n  _createClass(SweepLine, [{\\n    key: 'process',\\n    value: function process(event) {\\n      var segment = event.segment;\\n      var newEvents = [];\\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\\n\\n      var prevNode = this.tree.prev(node);\\n      var prevSeg = prevNode ? prevNode.key : null;\\n\\n      var nextNode = this.tree.next(node);\\n      var nextSeg = nextNode ? nextNode.key : null;\\n\\n      if (event.isLeft) {\\n        var mySplitters = [];\\n\\n        // Check for intersections against the previous segment in the sweep line\\n        if (prevSeg) {\\n          var prevInters = prevSeg.getIntersections(segment);\\n          if (prevInters.length > 0) {\\n            var newEventsFromSplit = this._possibleSplit(prevSeg, prevInters);\\n            for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\\n              newEvents.push(newEventsFromSplit[i]);\\n            }\\n            for (var _i = 0, _iMax = prevInters.length; _i < _iMax; _i++) {\\n              var pt = prevInters[_i];\\n              if (!segment.isAnEndpoint(pt)) mySplitters.push(pt);\\n            }\\n          }\\n        }\\n\\n        // Check for intersections against the next segment in the sweep line\\n        if (nextSeg) {\\n          var nextInters = nextSeg.getIntersections(segment);\\n          if (nextInters.length > 0) {\\n            var _newEventsFromSplit = this._possibleSplit(nextSeg, nextInters);\\n            for (var _i2 = 0, _iMax2 = _newEventsFromSplit.length; _i2 < _iMax2; _i2++) {\\n              newEvents.push(_newEventsFromSplit[_i2]);\\n            }\\n            for (var _i3 = 0, _iMax3 = nextInters.length; _i3 < _iMax3; _i3++) {\\n              var _pt = nextInters[_i3];\\n              if (!segment.isAnEndpoint(_pt)) mySplitters.push(_pt);\\n            }\\n          }\\n        }\\n\\n        // did we get some intersections?\\n        if (newEvents.length > 0 || mySplitters.length > 0) {\\n          this.tree.remove(segment);\\n\\n          if (mySplitters.length > 0) {\\n            var _newEventsFromSplit2 = segment.split(mySplitters);\\n            for (var _i4 = 0, _iMax4 = _newEventsFromSplit2.length; _i4 < _iMax4; _i4++) {\\n              newEvents.push(_newEventsFromSplit2[_i4]);\\n            }\\n          }\\n\\n          // Make sure sweep line ordering is totally consistent for later\\n          // use with the segment 'prev' pointers - re-do the current event.\\n          newEvents.push(event);\\n          return newEvents;\\n        }\\n\\n        this.segments.push(segment);\\n        segment.registerPrev(prevSeg);\\n      } else {\\n        // event.isRight\\n\\n        // since we're about to be removed from the sweep line, check for\\n        // intersections between our previous and next segments\\n        if (prevSeg && nextSeg) {\\n          var inters = prevSeg.getIntersections(nextSeg);\\n          if (inters.length > 0) {\\n            var _newEventsFromSplit3 = this._possibleSplit(prevSeg, inters);\\n            for (var _i5 = 0, _iMax5 = _newEventsFromSplit3.length; _i5 < _iMax5; _i5++) {\\n              newEvents.push(_newEventsFromSplit3[_i5]);\\n            }\\n            _newEventsFromSplit3 = this._possibleSplit(nextSeg, inters);\\n            for (var _i6 = 0, _iMax6 = _newEventsFromSplit3.length; _i6 < _iMax6; _i6++) {\\n              newEvents.push(_newEventsFromSplit3[_i6]);\\n            }\\n          }\\n        }\\n\\n        this.tree.remove(segment);\\n      }\\n\\n      if (this.prevEvent && (0, _flp.cmpPoints)(this.prevEvent.point, event.point) === 0) {\\n        this.prevEvent.link(event);\\n      }\\n      this.prevEvent = event;\\n\\n      return newEvents;\\n    }\\n  }, {\\n    key: '_possibleSplit',\\n    value: function _possibleSplit(segment, intersections) {\\n      var splitters = [];\\n      for (var i = 0, iMax = intersections.length; i < iMax; i++) {\\n        var pt = intersections[i];\\n        if (!segment.isAnEndpoint(pt)) splitters.push(pt);\\n      }\\n\\n      var newEvents = void 0;\\n      if (splitters.length > 0) {\\n        this.tree.remove(segment);\\n        newEvents = segment.split(splitters);\\n        this.tree.insert(segment);\\n      } else newEvents = [];\\n      return newEvents;\\n    }\\n  }]);\\n\\n  return SweepLine;\\n}();\\n\\nexports.default = SweepLine;\\n\\n//# sourceURL=webpack://polygon-clipping/./src/sweep-line.js?\");\n\n/***/ }),\n\n/***/ \"./src/vector.js\":\n/*!***********************!*\\\n  !*** ./src/vector.js ***!\n  \\***********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\neval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.cosineOfAngle = exports.sineOfAngle = exports.compareVectorAngles = exports.dotProduct = exports.crossProduct = undefined;\\n\\nvar _flp = __webpack_require__(/*! ./flp */ \\\"./src/flp.js\\\");\\n\\n/* Cross Product of two vectors with first point at origin */\\nvar crossProduct = exports.crossProduct = function crossProduct(a, b) {\\n  return a.x * b.y - a.y * b.x;\\n};\\n\\n/* Dot Product of two vectors with first point at origin */\\nvar dotProduct = exports.dotProduct = function dotProduct(a, b) {\\n  return a.x * b.x + a.y * b.y;\\n};\\n\\n/* Comparator for two vectors with same starting point */\\nvar compareVectorAngles = exports.compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\\n  var v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y };\\n  var v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y };\\n  var kross = crossProduct(v1, v2);\\n  return (0, _flp.cmp)(kross, 0);\\n};\\n\\nvar length = function length(v) {\\n  return Math.sqrt(dotProduct(v, v));\\n};\\n\\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\\nvar sineOfAngle = exports.sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\\n};\\n\\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\\nvar cosineOfAngle = exports.cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\\n  var vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y };\\n  var vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y };\\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\\n};\\n\\n//# sourceURL=webpack://polygon-clipping/./src/vector.js?\");\n\n/***/ })\n\n/******/ });\n});","\nvar content = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\", function() {\n\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!./PaintPolygon.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","var escape = require(\"../node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"\\n/*   Icons  */\\n\\n.leaflet-control-paintpolygon-icon {\\n    background-image: url(\" + escape(require(\"./PaintPolygon.svg\")) + \");\\n    background-repeat: no-repeat;\\n    height: 30px;\\n    width: 30px;\\n}\\n\\n.leaflet-control-paintpolygon-icon-active {\\n    -webkit-filter: invert(75%); /* Safari 6.0 - 9.0 */\\n    filter: invert(75%);\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-trash {\\n    background-position: 0px 0px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-brush {\\n    background-position: 0px -30px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-eraser {\\n    background-position: 0px -60px;\\n}\\n\\n.leaflet-control-paintpolygon-icon.leaflet-control-paintpolygon-icon-size {\\n    background-position: 0px -90px;\\n}\\n\\n\\n/* Menu */\\n\\n.leaflet-control-paintpolygon-menu  {\\n    background-color: #fff;\\n    position: absolute;\\n    border: 0!important;\\n    max-width: 0;\\n    max-height: 30px;\\n    -webkit-transition: all 0.5s;\\n    -moz-transition: all 0.5s;\\n    -ms-transition: all 0.5s;\\n    -o-transition: all 0.5s;\\n    transition: all 0.5s;\\n    display: inline-block;\\n    overflow: hidden;\\n    white-space: nowrap;\\n}\\n.leaflet-control-paintpolygon-menu-content  {\\n    padding: 5px;\\n    display: inline-block;\\n    max-width: 250px;\\n}\\n\\n.leaflet-control-paintpolygon-menu-open  {\\n    border: inherit!important;\\n    max-width: 250px;\\n    max-height: 200px;\\n}\\n\\n.leaflet-control-container .leaflet-top.leaflet-right .leaflet-control-paintpolygon-menu {\\n    top: 60px;\\n    right: 30px;\\n}\\n.leaflet-control-container .leaflet-top.leaflet-left .leaflet-control-paintpolygon-menu {\\n    top: 60px;\\n    left: 30px;\\n}\\n.leaflet-control-container .leaflet-bottom.leaflet-right .leaflet-control-paintpolygon-menu {\\n    bottom: 0px;\\n    right: 30px;\\n}\\n.leaflet-control-container .leaflet-bottom.leaflet-left .leaflet-control-paintpolygon-menu {\\n    bottom: 0px;\\n    left: 30px;\\n}\\n\\n\", \"\"]);\n\n// exports\n","module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","module.exports = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMzAiCiAgIGhlaWdodD0iMTIwIgogICB2aWV3Qm94PSIwIDAgNy45Mzc1IDMxLjc1MDAwMSIKICAgdmVyc2lvbj0iMS4xIgogICBpZD0ic3ZnOCIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi4zICgyNDA1NTQ2LCAyMDE4LTAzLTExKSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iUGFpbnRQb2x5Z29uLnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczIiPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxU3N0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxU3N0YXJ0IgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5NzMiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuMiwwLDAsMC4yLDEuMiwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTWVuZCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9Im1hcmtlcjE1MjMiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDE1MjEiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjQsMCwwLC0wLjQsLTQsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MkxlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5ODIiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEuMSwwLDAsLTEuMSwtMS4xLDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMZW5kIgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0iQXJyb3cxTGVuZCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoOTY0IgogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMC44LDAsMCwtMC44LC0xMCwwKSIKICAgICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDwvbWFya2VyPgogICAgPG1hcmtlcgogICAgICAgaW5rc2NhcGU6c3RvY2tpZD0iQXJyb3cxTHN0YXJ0IgogICAgICAgb3JpZW50PSJhdXRvIgogICAgICAgcmVmWT0iMCIKICAgICAgIHJlZlg9IjAiCiAgICAgICBpZD0ibWFya2VyMTI5NSIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoMTI5MyIKICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44LDAsMCwwLjgsMTAsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1lbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzFNZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5NzAiCiAgICAgICAgIGQ9Ik0gMCwwIDUsLTUgLTEyLjUsMCA1LDUgWiIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MS4wMDAwMDAwM3B0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjQsMCwwLC0wLjQsLTQsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MlNlbmQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJTZW5kIgogICAgICAgc3R5bGU9Im92ZXJmbG93OnZpc2libGUiCiAgICAgICBpbmtzY2FwZTppc3N0b2NrPSJ0cnVlIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGg5OTQiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuNjI1O3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJNIDguNzE4NTg3OCw0LjAzMzczNTIgLTIuMjA3Mjg5NSwwLjAxNjAxMzI2IDguNzE4NTg4NCwtNC4wMDE3MDc4IGMgLTEuNzQ1NDk4NCwyLjM3MjA2MDkgLTEuNzM1NDQwOCw1LjYxNzQ1MTkgLTZlLTcsOC4wMzU0NDMgeiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuMywwLDAsLTAuMywwLjY5LDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzJMc3RhcnQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzJMc3RhcnQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDk3OSIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC42MjU7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGQ9Ik0gOC43MTg1ODc4LDQuMDMzNzM1MiAtMi4yMDcyODk1LDAuMDE2MDEzMjYgOC43MTg1ODg0LC00LjAwMTcwNzggYyAtMS43NDU0OTg0LDIuMzcyMDYwOSAtMS43MzU0NDA4LDUuNjE3NDUxOSAtNmUtNyw4LjAzNTQ0MyB6IgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLjEsMCwwLDEuMSwxLjEsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICAgIDxtYXJrZXIKICAgICAgIGlua3NjYXBlOnN0b2NraWQ9IkFycm93MU1zdGFydCIKICAgICAgIG9yaWVudD0iYXV0byIKICAgICAgIHJlZlk9IjAiCiAgICAgICByZWZYPSIwIgogICAgICAgaWQ9IkFycm93MU1zdGFydCIKICAgICAgIHN0eWxlPSJvdmVyZmxvdzp2aXNpYmxlIgogICAgICAgaW5rc2NhcGU6aXNzdG9jaz0idHJ1ZSI+CiAgICAgIDxwYXRoCiAgICAgICAgIGlkPSJwYXRoOTY3IgogICAgICAgICBkPSJNIDAsMCA1LC01IC0xMi41LDAgNSw1IFoiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEuMDAwMDAwMDNwdDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLjQsMCwwLDAuNCw0LDApIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPC9tYXJrZXI+CiAgICA8bWFya2VyCiAgICAgICBpbmtzY2FwZTpzdG9ja2lkPSJBcnJvdzFMc3RhcnQiCiAgICAgICBvcmllbnQ9ImF1dG8iCiAgICAgICByZWZZPSIwIgogICAgICAgcmVmWD0iMCIKICAgICAgIGlkPSJBcnJvdzFMc3RhcnQiCiAgICAgICBzdHlsZT0ib3ZlcmZsb3c6dmlzaWJsZSIKICAgICAgIGlua3NjYXBlOmlzc3RvY2s9InRydWUiPgogICAgICA8cGF0aAogICAgICAgICBpZD0icGF0aDk2MSIKICAgICAgICAgZD0iTSAwLDAgNSwtNSAtMTIuNSwwIDUsNSBaIgogICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxLjAwMDAwMDAzcHQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44LDAsMCwwLjgsMTAsMCkiCiAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8L21hcmtlcj4KICA8L2RlZnM+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIGlkPSJiYXNlIgogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxLjAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIxNiIKICAgICBpbmtzY2FwZTpjeD0iMTguMTAyNDY1IgogICAgIGlua3NjYXBlOmN5PSIxMTEuMTcyNDEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9InB4IgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0idHJ1ZSIKICAgICB1bml0cz0icHgiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjIwIgogICAgIGdyaWR0b2xlcmFuY2U9IjUiCiAgICAgaW5rc2NhcGU6c25hcC1ncmlkcz0iZmFsc2UiCiAgICAgZml0LW1hcmdpbi10b3A9IjgiCiAgICAgZml0LW1hcmdpbi1sZWZ0PSI4IgogICAgIGZpdC1tYXJnaW4tcmlnaHQ9IjgiCiAgICAgZml0LW1hcmdpbi1ib3R0b209IjgiCiAgICAgaW5rc2NhcGU6Z3VpZGUtYmJveD0idHJ1ZSIKICAgICBndWlkZXRvbGVyYW5jZT0iOSIKICAgICBpbmtzY2FwZTpzbmFwLXRvLWd1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjE5MjAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAxNiIKICAgICBpbmtzY2FwZTp3aW5kb3cteD0iMCIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMjciCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQzNzEzIgogICAgICAgc3BhY2luZ3g9IjIuNjQ1ODMzNCIKICAgICAgIHNwYWNpbmd5PSIyLjY0NTgzMzQiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9ImZhbHNlIgogICAgICAgZW1wc3BhY2luZz0iMyIKICAgICAgIG9yaWdpbng9IjAiCiAgICAgICBvcmlnaW55PSIwIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iMS4zMjcxNjAzLDI0LjI4NjQ0OCIKICAgICAgIG9yaWVudGF0aW9uPSIxLDAiCiAgICAgICBpZD0iZ3VpZGU0NTM0IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249IjYuNjEyNDE1MywyMi4yNjM1NTIiCiAgICAgICBvcmllbnRhdGlvbj0iMSwwIgogICAgICAgaWQ9Imd1aWRlNDUzOCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMi4wMDUzNTY3LDIyLjQ4NTcyIgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTQ1NDAiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTEuNzM2MzI4MiwxNy4xOTc5MTciCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU0MiIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMS44MTkwMTA1LDE0LjU1MjA4NCIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU0NTQ0IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii0xLjI4OTg0MzgsOS4yNDM4ODA0IgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTQ1NDYiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTEuNDM4NjcxOSw2LjYxNDU4MzUiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU0OCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMC45OTIxODc1MiwxLjI4OTg0MzgiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlNDU1MCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItNC4zMjY0MjU1LDExLjkwMzUxNyIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU0NTUyIgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii0xMi43MzMwNzMsMzAuNDI3MDg0IgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTk0MSIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgICA8c29kaXBvZGk6Z3VpZGUKICAgICAgIHBvc2l0aW9uPSItMTcuMDQ4NDU1LDI1LjE0MDA0MSIKICAgICAgIG9yaWVudGF0aW9uPSIwLDEiCiAgICAgICBpZD0iZ3VpZGU5NDkiCiAgICAgICBpbmtzY2FwZTpsb2NrZWQ9ImZhbHNlIiAvPgogICAgPHNvZGlwb2RpOmd1aWRlCiAgICAgICBwb3NpdGlvbj0iLTUuOTYzNDUxMywyOC40Mzc0NzkiCiAgICAgICBvcmllbnRhdGlvbj0iMCwxIgogICAgICAgaWQ9Imd1aWRlOTU4IgogICAgICAgaW5rc2NhcGU6bG9ja2VkPSJmYWxzZSIgLz4KICAgIDxzb2RpcG9kaTpndWlkZQogICAgICAgcG9zaXRpb249Ii03LjE1NjE0MTYsMjUuODQxNjIzIgogICAgICAgb3JpZW50YXRpb249IjAsMSIKICAgICAgIGlkPSJndWlkZTk2MCIKICAgICAgIGlua3NjYXBlOmxvY2tlZD0iZmFsc2UiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgICA8Y2M6bGljZW5zZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cHM6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwtMy4wLnR4dCIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iQ2FscXVlIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEuNTU2OTkzNCwtMjU5LjIyMzg0KSI+CiAgICA8ZwogICAgICAgaWQ9Imc0NjcwIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44MzY0NzYyNiwwLDAsMC44MzMzMTMwNSwwLjM5MTczNTYzLDQ2LjUxNjg3NykiPgogICAgICA8cmVjdAogICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsLTAuMzM0ODI0OTcsMC45NDIyODAzNCwwLDApIgogICAgICAgICByeT0iMC42NDczODQ3IgogICAgICAgICB5PSIyOTIuNzkyNDUiCiAgICAgICAgIHg9Ijk5LjUyODIwNiIKICAgICAgICAgaGVpZ2h0PSI2LjczODQxMjkiCiAgICAgICAgIHdpZHRoPSI0LjA4MTQxNzEiCiAgICAgICAgIGlkPSJyZWN0NDUzMiIKICAgICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMzA0NjQ0NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgICAgPHJlY3QKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLC0wLjMzNDgyNDk4LDAuOTQyMjgwMzQsMCwwKSIKICAgICAgICAgcnk9IjAuNTc0OTAwMjEiCiAgICAgICAgIHk9IjI5NS44OTg2OCIKICAgICAgICAgeD0iOTkuNTI2NDUxIgogICAgICAgICBoZWlnaHQ9IjMuNjMyMTU4OCIKICAgICAgICAgd2lkdGg9IjQuMDgzMTY5NSIKICAgICAgICAgaWQ9InJlY3Q0NTMyLTMiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjMwNDY0NDQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjA7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICA8L2c+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4xMDI0MDM2NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46YmV2ZWw7c3Ryb2tlLW1pdGVybGltaXQ6MDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJyZWN0NDYzMyIKICAgICAgIHdpZHRoPSIwLjUzNjc5NTk3IgogICAgICAgaGVpZ2h0PSIzLjA3NzAxMTEiCiAgICAgICB4PSI4NS4wMjA1MzgiCiAgICAgICB5PSIyODAuNjQyNzkiCiAgICAgICByeT0iMC4yMDI3NTE2NSIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwtMC4yOTExMDkwMiwwLjk1NjY4OTg5LDAsMCkiCiAgICAgICByeD0iMC4yNjgzOTc5OSIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE2NzQxNjk1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpiZXZlbDtzdHJva2UtbWl0ZXJsaW1pdDowO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InJlY3Q0NjM5IgogICAgICAgd2lkdGg9IjMuMzc3NTQ5NiIKICAgICAgIGhlaWdodD0iMC4zMzIyMTgwMiIKICAgICAgIHg9IjEuMDUzMjMyMSIKICAgICAgIHk9IjI3MS4zMzk2NiIKICAgICAgIHJ5PSIwLjE2NjEwOTAxIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxODI3NDM7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS4zMTYyMzgsMjcxLjY0NDIgYyAtMC4yNDkxNjM2LDEuMjQ1ODEgLTEuMjA0MjkwMjksMi4xMzE3MiAtMS4yMDQyOTAyOSwyLjEzMTcyIGwgNC41NDAzMTI3OSwwLjAyNzYgYyAwLDAgLTAuNTg4MzAzLC0xLjMxNDk3IC0wLjQ0OTg3ODgsLTIuMjI4NTkiCiAgICAgICBpZD0icGF0aDQ2NDEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjY2NjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS43NzMwMzc4LDI3MS42NDQxOSBjIC0wLjIwNzYzNjMsMC45NzU4OSAtMC43MjY3MjcsMS43NzE4MyAtMC43MjY3MjcsMS43NzE4MyIKICAgICAgIGlkPSJwYXRoNDY0MyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMi4xNjc1NDYyLDI3MS42NTgwMyBjIC0wLjE2NjEwOSwwLjkwNjY4IC0wLjUzOTg1NDIsMS43NTc5OSAtMC41Mzk4NTQyLDEuNzU3OTkiCiAgICAgICBpZD0icGF0aDQ2NDUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjYyIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjIyMTQ3ODY3cHg7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIuNTc5NDIzNCwyNzEuNjM3MjYgYyAtMC4xMTc2NjA2LDAuOTU1MTMgLTAuMzg3NTg3NywxLjc3ODc2IC0wLjM4NzU4NzcsMS43Nzg3NiIKICAgICAgIGlkPSJwYXRoNDY0NyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMi45NzcyOTYzLDI3MS42NTExMiBjIC0wLjE3MzAzMDIsMS4zMjg4NyAtMC4yMDc2MzYyLDEuNzY0OSAtMC4yMDc2MzYyLDEuNzY0OSIKICAgICAgIGlkPSJwYXRoNDY0OSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMjIxNDc4NjdweDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMy4zNjExOTYxLDI3MS42NjQ5NiBjIDAuMDIwNzY0LDEuMDY1ODUgLTAuMDA2OTMsMS43NTEwNiAtMC4wMDY5MywxLjc1MTA2IgogICAgICAgaWQ9InBhdGg0NjUxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY2MiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4yMjE0Nzg2N3B4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzLjcxNzg5NzMsMjcxLjY3MTg4IGMgMC4wMjA3NjQsMC44NjUxNSAwLjI2MzAwNTksMS43NDQxNCAwLjI2MzAwNTksMS43NDQxNCIKICAgICAgIGlkPSJwYXRoNDY1MyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjIiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTk1NjU4NTY7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoOTUxIgogICAgICAgY3g9IjIuNDMwMzM0MSIKICAgICAgIGN5PSIyODcuMDA5OTUiCiAgICAgICByeD0iMi43ODM1NjUzIgogICAgICAgcnk9IjIuODIwODQ3NSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE1MTQwODMzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTowLjQ1NDIyNDk2LCAwLjE1MTQwODMzO3N0cm9rZS1kYXNob2Zmc2V0OjAuMTQyODc0OTk7c3Ryb2tlLW9wYWNpdHk6MTttYXJrZXItc3RhcnQ6dXJsKCNBcnJvdzJMc3RhcnQpO21hcmtlci1lbmQ6dXJsKCNBcnJvdzJMZW5kKSIKICAgICAgIGQ9Ik0gMC4wMjY0ODAxMiwyODcuMDA5OTUgSCA0LjgzNDE4ODEiCiAgICAgICBpZD0icGF0aDc2OTMiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMTU5O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowLjU0MDg1MDM3O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDk1NCIKICAgICAgIHdpZHRoPSIyLjY0MjYyNzUiCiAgICAgICBoZWlnaHQ9IjQuMDIyNDA1NiIKICAgICAgIHg9IjEuMTA5MDIwNCIKICAgICAgIHk9IjI2MS44MTE0IgogICAgICAgcng9IjAuMzIwNjM1MzIiCiAgICAgICByeT0iMC4yNDIyMTE1MSIgLz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjE1OTAwMDAxO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDoyLjA0NDE1ODk0O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icmVjdDk1NiIKICAgICAgIHdpZHRoPSIzLjU3ODA3MDkiCiAgICAgICBoZWlnaHQ9IjAuNTg0NjUyMTMiCiAgICAgICB4PSIwLjYwMjc5NDY1IgogICAgICAgeT0iMjYxLjIyMzkxIgogICAgICAgcng9IjAuMzIwNjM1MzIiCiAgICAgICByeT0iMC4yNDIyMTE1MSIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAyLjEzMzM5MywyNjIuNTM2MzYgdiAyLjU5NTg2IgogICAgICAgaWQ9InBhdGg5NjgiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjAuMDY1O3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDIuNzE0OTI1MiwyNjIuNTM2MzYgdiAyLjU5NTg2IgogICAgICAgaWQ9InBhdGg5NjgtNiIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiIC8+CiAgICA8cGF0aAogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MC4wNjU7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMS41NTE4NjA4LDI2Mi41MzYzNiB2IDIuNTk1ODYiCiAgICAgICBpZD0icGF0aDk2OC03IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDowLjA2NTtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSAzLjI5NjQ1NzIsMjYyLjUzNjM2IHYgMi41OTU4NiIKICAgICAgIGlkPSJwYXRoOTY4LTUiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgogIDwvZz4KPC9zdmc+Cg==\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","/**\r\n * @module helpers\r\n */\r\n\r\n/**\r\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\r\n *\r\n * @memberof helpers\r\n * @type {number}\r\n */\r\nexport let earthRadius = 6371008.8;\r\n\r\n/**\r\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport let factors = {\r\n    centimeters: earthRadius * 100,\r\n    centimetres: earthRadius * 100,\r\n    degrees: 180 / Math.PI, // See https://github.com/Turfjs/turf/issues/1406\r\n    feet: earthRadius * 3.28084,\r\n    inches: earthRadius * 39.370,\r\n    kilometers: earthRadius / 1000,\r\n    kilometres: earthRadius / 1000,\r\n    meters: earthRadius,\r\n    metres: earthRadius,\r\n    miles: earthRadius / 1609.344,\r\n    millimeters: earthRadius * 1000,\r\n    millimetres: earthRadius * 1000,\r\n    nauticalmiles: earthRadius / 1852,\r\n    radians: 1,\r\n    yards: earthRadius / 1.0936,\r\n};\r\n\r\n/**\r\n * Area of measurement factors based on 1 square meter.\r\n *\r\n * @memberof helpers\r\n * @type {Object}\r\n */\r\nexport let areaFactors = {\r\n    acres: 0.000247105,\r\n    centimeters: 10000,\r\n    centimetres: 10000,\r\n    feet: 10.763910417,\r\n    inches: 1550.003100006,\r\n    kilometers: 0.000001,\r\n    kilometres: 0.000001,\r\n    meters: 1,\r\n    metres: 1,\r\n    miles: 3.86e-7,\r\n    millimeters: 1000000,\r\n    millimetres: 1000000,\r\n    yards: 1.195990046,\r\n};\r\n\r\n/**\r\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\r\n *\r\n * @name feature\r\n * @param {Geometry} geometry input geometry\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature} a GeoJSON Feature\r\n * @example\r\n * var geometry = {\r\n *   'type': 'Point',\r\n *   'coordinates': [110, 50]\r\n * };\r\n *\r\n * var feature = turf.feature(geometry);\r\n *\r\n * //=feature\r\n */\r\nexport function feature(geometry, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const feat = {type: 'Feature'};\r\n    if (options.id === 0 || options.id) { feat.id = options.id; }\r\n    if (options.bbox) { feat.bbox = options.bbox; }\r\n    feat.properties = properties || {};\r\n    feat.geometry = geometry;\r\n    return feat;\r\n}\r\n\r\n/**\r\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\r\n * For GeometryCollection type use `helpers.geometryCollection`\r\n *\r\n * @name geometry\r\n * @param {string} type Geometry Type\r\n * @param {Array<any>} coordinates Coordinates\r\n * @returns {Geometry} a GeoJSON Geometry\r\n * @example\r\n * var type = 'Point';\r\n * var coordinates = [110, 50];\r\n * var geometry = turf.geometry(type, coordinates);\r\n * // => geometry\r\n */\r\nexport function geometry(type, coordinates) {\r\n    switch (type) {\r\n    case 'Point': return point(coordinates).geometry;\r\n    case 'LineString': return lineString(coordinates).geometry;\r\n    case 'Polygon': return polygon(coordinates).geometry;\r\n    case 'MultiPoint': return multiPoint(coordinates).geometry;\r\n    case 'MultiLineString': return multiLineString(coordinates).geometry;\r\n    case 'MultiPolygon': return multiPolygon(coordinates).geometry;\r\n    default: throw new Error(type + ' is invalid');\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a {@link Point} {@link Feature} from a Position.\r\n *\r\n * @name point\r\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Point>} a Point feature\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n *\r\n * //=point\r\n */\r\nexport function point(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'Point',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\r\n *\r\n * @name points\r\n * @param {Array<Array<number>>} coordinates an array of Points\r\n * @param {Object} [properties={}] Translate these properties to each Feature\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Point>} Point Feature\r\n * @example\r\n * var points = turf.points([\r\n *   [-75, 39],\r\n *   [-80, 45],\r\n *   [-78, 50]\r\n * ]);\r\n *\r\n * //=points\r\n */\r\nexport function points(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return point(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\r\n *\r\n * @name polygon\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<Polygon>} Polygon Feature\r\n * @example\r\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\r\n *\r\n * //=polygon\r\n */\r\nexport function polygon(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    for (const ring of coordinates) {\r\n        if (ring.length < 4) {\r\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\r\n        }\r\n        for (let j = 0; j < ring[ring.length - 1].length; j++) {\r\n            // Check if first point of Polygon contains two numbers\r\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\r\n                throw new Error('First and last Position are not equivalent.');\r\n            }\r\n        }\r\n    }\r\n    const geom = {\r\n        type: 'Polygon',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\r\n *\r\n * @name polygons\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\r\n * @example\r\n * var polygons = turf.polygons([\r\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\r\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\r\n * ]);\r\n *\r\n * //=polygons\r\n */\r\nexport function polygons(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return polygon(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\r\n *\r\n * @name lineString\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<LineString>} LineString Feature\r\n * @example\r\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\r\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\r\n *\r\n * //=linestring1\r\n * //=linestring2\r\n */\r\nexport function lineString(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    if (coordinates.length < 2) { throw new Error('coordinates must be an array of two or more positions'); }\r\n    const geom = {\r\n        type: 'LineString',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\r\n *\r\n * @name lineStrings\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\r\n * associated with the FeatureCollection\r\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\r\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\r\n * @example\r\n * var linestrings = turf.lineStrings([\r\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\r\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\r\n * ]);\r\n *\r\n * //=linestrings\r\n */\r\nexport function lineStrings(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    return featureCollection(coordinates.map((coords) => {\r\n        return lineString(coords, properties);\r\n    }), options);\r\n}\r\n\r\n/**\r\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\r\n *\r\n * @name featureCollection\r\n * @param {Feature[]} features input features\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {FeatureCollection} FeatureCollection of Features\r\n * @example\r\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\r\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\r\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\r\n *\r\n * var collection = turf.featureCollection([\r\n *   locationA,\r\n *   locationB,\r\n *   locationC\r\n * ]);\r\n *\r\n * //=collection\r\n */\r\nexport function featureCollection(features, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const fc = {type: 'FeatureCollection'};\r\n    if (options.id) { fc.id = options.id; }\r\n    if (options.bbox) { fc.bbox = options.bbox; }\r\n    fc.features = features;\r\n    return fc;\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiLineString>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiLineString\r\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiLineString>} a MultiLineString feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\r\n *\r\n * //=multiLine\r\n */\r\nexport function multiLineString(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiLineString',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiPoint>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPoint\r\n * @param {Array<Array<number>>} coordinates an array of Positions\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPoint>} a MultiPoint feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\r\n *\r\n * //=multiPt\r\n */\r\nexport function multiPoint(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiPoint',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<MultiPolygon>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name multiPolygon\r\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<MultiPolygon>} a multipolygon feature\r\n * @throws {Error} if no coordinates are passed\r\n * @example\r\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\r\n *\r\n * //=multiPoly\r\n *\r\n */\r\nexport function multiPolygon(coordinates, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'MultiPolygon',\r\n        coordinates,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Creates a {@link Feature<GeometryCollection>} based on a\r\n * coordinate array. Properties can be added optionally.\r\n *\r\n * @name geometryCollection\r\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\r\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\r\n * @param {Object} [options={}] Optional Parameters\r\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\r\n * @param {string|number} [options.id] Identifier associated with the Feature\r\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\r\n * @example\r\n * var pt = turf.geometry('Point', [100, 0]);\r\n * var line = turf.geometry('LineString', [[101, 0], [102, 1]]);\r\n * var collection = turf.geometryCollection([pt, line]);\r\n *\r\n * // => collection\r\n */\r\nexport function geometryCollection(geometries, properties, options) {\r\n    options = checkIfOptionsExist(options);\r\n    const geom = {\r\n        type: 'GeometryCollection',\r\n        geometries,\r\n    };\r\n    return feature(geom, properties, options);\r\n}\r\n\r\n/**\r\n * Round number to precision\r\n *\r\n * @param {number} num Number\r\n * @param {number} [precision=0] Precision\r\n * @returns {number} rounded number\r\n * @example\r\n * turf.round(120.4321)\r\n * //=120\r\n *\r\n * turf.round(120.4321, 2)\r\n * //=120.43\r\n */\r\nexport function round(num, precision) {\r\n    if (precision && !(precision >= 0)) { throw new Error('precision must be a positive number'); }\r\n    const multiplier = Math.pow(10, precision || 0);\r\n    return Math.round(num * multiplier) / multiplier;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name radiansToLength\r\n * @param {number} radians in radians across the sphere\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} distance\r\n */\r\nexport function radiansToLength(radians, units) {\r\n    if (radians === undefined || radians === null) throw new Error('radians is required');\r\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\r\n\r\n    var factor = factors[units || 'kilometers'];\r\n    if (!factor) { throw new Error(units + ' units is invalid'); }\r\n    return radians * factor;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @name lengthToRadians\r\n * @param {number} distance in real units\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} radians\r\n */\r\nexport function lengthToRadians(distance, units) {\r\n    if (distance === undefined || distance === null) throw new Error('distance is required');\r\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\r\n\r\n    var factor = factors[units || 'kilometers'];\r\n    if (!factor) { throw new Error(units + ' units is invalid'); }\r\n    return distance / factor;\r\n}\r\n\r\n/**\r\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\r\n *\r\n * @name lengthToDegrees\r\n * @param {number} distance in real units\r\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres,\r\n * meters, kilometres, kilometers.\r\n * @returns {number} degrees\r\n */\r\nexport function lengthToDegrees(distance, units) {\r\n    if (units === null) units = 'kilometers';\r\n    return radiansToDegrees(lengthToRadians(distance, units));\r\n}\r\n\r\n/**\r\n * Converts any bearing angle from the north line direction (positive clockwise)\r\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\r\n *\r\n * @name bearingToAzimuth\r\n * @param {number} bearing angle, between -180 and +180 degrees\r\n * @returns {number} angle between 0 and 360 degrees\r\n */\r\nexport function bearingToAzimuth(bearing) {\r\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\r\n\r\n    let angle = bearing % 360;\r\n    if (angle < 0) { angle += 360; }\r\n    return angle;\r\n}\r\n\r\n/**\r\n * Converts an angle in radians to degrees\r\n *\r\n * @name radiansToDegrees\r\n * @param {number} radians angle in radians\r\n * @returns {number} degrees between 0 and 360 degrees\r\n */\r\nexport function radiansToDegrees(radians) {\r\n    if (radians === null || radians === undefined) throw new Error('radians is required');\r\n\r\n    const degrees = radians % (2 * Math.PI);\r\n    return degrees * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * Converts an angle in degrees to radians\r\n *\r\n * @name degreesToRadians\r\n * @param {number} degrees angle between 0 and 360 degrees\r\n * @returns {number} angle in radians\r\n */\r\nexport function degreesToRadians(degrees) {\r\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\r\n\r\n    const radians = degrees % 360;\r\n    return radians * Math.PI / 180;\r\n}\r\n\r\n/**\r\n * Converts a length to the requested unit.\r\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\r\n *\r\n * @param {number} length to be converted\r\n * @param {Units} [originalUnit='kilometers'] of the length\r\n * @param {Units} [finalUnit='kilometers'] returned unit\r\n * @returns {number} the converted length\r\n */\r\nexport function convertLength(length, originalUnit, finalUnit) {\r\n    if (length === null || length === undefined) throw new Error('length is required');\r\n\r\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\r\n}\r\n\r\n/**\r\n * Converts a area to the requested unit.\r\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\r\n * @param {number} area to be converted\r\n * @param {Units} [originalUnit='meters'] of the distance\r\n * @param {Units} [finalUnit='kilometers'] returned unit\r\n * @returns {number} the converted distance\r\n */\r\nexport function convertArea(area, originalUnit, finalUnit) {\r\n    if (area === null || area === undefined) throw new Error('area is required');\r\n    if (!(area >= 0)) throw new Error('area must be a positive number');\r\n\r\n    var startFactor = areaFactors[originalUnit || 'meters'];\r\n    if (!startFactor) throw new Error('invalid original units');\r\n\r\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\r\n    if (!finalFactor) throw new Error('invalid final units');\r\n\r\n    return (area / startFactor) * finalFactor;\r\n}\r\n\r\n/**\r\n * isNumber\r\n *\r\n * @param {*} num Number to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isNumber(123)\r\n * //=true\r\n * turf.isNumber('foo')\r\n * //=false\r\n */\r\nexport function isNumber(num) {\r\n    return !isNaN(num) && num !== null && !Array.isArray(num);\r\n}\r\n\r\n/**\r\n * isObject\r\n *\r\n * @param {*} input variable to validate\r\n * @returns {boolean} true/false\r\n * @example\r\n * turf.isObject({elevation: 10})\r\n * //=true\r\n * turf.isObject('foo')\r\n * //=false\r\n */\r\nexport function isObject(input) {\r\n    return (!!input) && (input.constructor === Object);\r\n}\r\n\r\n/**\r\n * Validate BBox\r\n *\r\n * @private\r\n * @param {Array<number>} bbox BBox to validate\r\n * @returns {void}\r\n * @throws Error if BBox is not valid\r\n * @example\r\n * validateBBox([-180, -40, 110, 50])\r\n * //=OK\r\n * validateBBox([-180, -40])\r\n * //=Error\r\n * validateBBox('Foo')\r\n * //=Error\r\n * validateBBox(5)\r\n * //=Error\r\n * validateBBox(null)\r\n * //=Error\r\n * validateBBox(undefined)\r\n * //=Error\r\n */\r\nexport function validateBBox(bbox) {\r\n    if (!bbox) { throw new Error('bbox is required'); }\r\n    if (!Array.isArray(bbox)) { throw new Error('bbox must be an Array'); }\r\n    if (bbox.length !== 4 && bbox.length !== 6) { throw new Error('bbox must be an Array of 4 or 6 numbers'); }\r\n    bbox.forEach((num) => {\r\n        if (!isNumber(num)) { throw new Error('bbox must only contain numbers'); }\r\n    });\r\n}\r\n\r\n/**\r\n * Validate Id\r\n *\r\n * @private\r\n * @param {string|number} id Id to validate\r\n * @returns {void}\r\n * @throws Error if Id is not valid\r\n * @example\r\n * validateId([-180, -40, 110, 50])\r\n * //=Error\r\n * validateId([-180, -40])\r\n * //=Error\r\n * validateId('Foo')\r\n * //=OK\r\n * validateId(5)\r\n * //=OK\r\n * validateId(null)\r\n * //=Error\r\n * validateId(undefined)\r\n * //=Error\r\n */\r\nexport function validateId(id) {\r\n    if (!id) { throw new Error('id is required'); }\r\n    if (['string', 'number'].indexOf(typeof id) === -1) { throw new Error('id must be a number or a string'); }\r\n}\r\n\r\nexport function checkIfOptionsExist(options) {\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    return options;\r\n}\r\n\r\n// Deprecated methods\r\nexport function radians2degrees() {\r\n    throw new Error('method has been renamed to `radiansToDegrees`');\r\n}\r\n\r\nexport function degrees2radians() {\r\n    throw new Error('method has been renamed to `degreesToRadians`');\r\n}\r\n\r\nexport function distanceToDegrees() {\r\n    throw new Error('method has been renamed to `lengthToDegrees`');\r\n}\r\n\r\nexport function distanceToRadians() {\r\n    throw new Error('method has been renamed to `lengthToRadians`');\r\n}\r\n\r\nexport function radiansToDistance() {\r\n    throw new Error('method has been renamed to `radiansToLength`');\r\n}\r\n\r\nexport function bearingToAngle() {\r\n    throw new Error('method has been renamed to `bearingToAzimuth`');\r\n}\r\n\r\nexport function convertDistance() {\r\n    throw new Error('method has been renamed to `convertLength`');\r\n}\r\n","import { isNumber } from '../helpers';\r\n\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nexport function getCoord(coord) {\r\n    if (!coord) { throw new Error('coord is required'); }\r\n\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === 'Point') {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n\r\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\r\n}\r\n\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nexport function getCoords(coords) {\r\n    if (Array.isArray(coords)) { return coords; }\r\n\r\n    // Feature\r\n    if (coords.type === 'Feature') {\r\n        if (coords.geometry !== null) { return coords.geometry.coordinates; }\r\n    } else {\r\n        // Geometry\r\n        if (coords.coordinates) { return coords.coordinates; }\r\n    }\r\n\r\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\r\n}\r\n\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nexport function containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error('coordinates must only contain numbers');\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nexport function geojsonType(value, type, name) {\r\n    if (!type || !name) { throw new Error('type and name required'); }\r\n\r\n    if (!value || value.type !== type) {\r\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\r\n    }\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nexport function featureOf(feature, type, name) {\r\n    if (!feature) { throw new Error('No feature passed'); }\r\n    if (!name) { throw new Error('.featureOf() requires a name'); }\r\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\r\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\r\n    }\r\n}\r\n\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nexport function collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) { throw new Error('No featureCollection passed'); }\r\n    if (!name) { throw new Error('.collectionOf() requires a name'); }\r\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\r\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\r\n    }\r\n    for (const feature of featureCollection.features) {\r\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\r\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   'type': 'Feature',\r\n *   'properties': {},\r\n *   'geometry': {\r\n *     'type': 'Point',\r\n *     'coordinates': [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={'type': 'Point', 'coordinates': [110, 40]}\r\n */\r\nexport function getGeom(geojson){\r\n    if (geojson.type === 'Feature') { return geojson.geometry; }\r\n    return geojson;\r\n}\r\n\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name='geojson'] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   'type': 'Feature',\r\n *   'properties': {},\r\n *   'geometry': {\r\n *     'type': 'Point',\r\n *     'coordinates': [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //='Point'\r\n */\r\nexport function getType(geojson, name) {\r\n    if (geojson.type === 'FeatureCollection') { return 'FeatureCollection'; }\r\n    if (geojson.type === 'GeometryCollection') { return 'GeometryCollection'; }\r\n    if (geojson.type === 'Feature' && geojson.geometry !== null) { return geojson.geometry.type; }\r\n    return geojson.type;\r\n}\r\n","// http://en.wikipedia.org/wiki/Haversine_formula\r\n// http://www.movable-type.co.uk/scripts/latlong.html\r\nimport { degreesToRadians, radiansToDegrees, lengthToRadians, point, checkIfOptionsExist } from '../helpers';\r\nimport { getCoord } from '../invariant';\r\n\r\n/**\r\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\r\n * degrees, radians, miles, or kilometers; and bearing in degrees.\r\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\r\n *\r\n * @name destination\r\n * @param {Coord} origin starting point\r\n * @param {number} distance distance from the origin point\r\n * @param {number} bearing ranging from -180 to 180\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\r\n * @param {Object} [options.properties={}] Translate properties to Point\r\n * @returns {Feature<Point>} destination point\r\n * @example\r\n * var point = turf.point([-75.343, 39.984]);\r\n * var distance = 50;\r\n * var bearing = 90;\r\n * var options = {units: 'miles'};\r\n *\r\n * var destination = turf.destination(point, distance, bearing, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [point, destination]\r\n * destination.properties['marker-color'] = '#f00';\r\n * point.properties['marker-color'] = '#0f0';\r\n */\r\nexport default function destination(origin, distance, bearing, options) {\r\n\r\n    options = checkIfOptionsExist(options);\r\n    // Handle input\r\n    const coordinates1 = getCoord(origin);\r\n    const longitude1 = degreesToRadians(coordinates1[0]);\r\n    const latitude1 = degreesToRadians(coordinates1[1]);\r\n    const bearingRad = degreesToRadians(bearing);\r\n    const radians = lengthToRadians(distance, options.units);\r\n\r\n    // Main\r\n    const latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\r\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\r\n    const longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1),\r\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\r\n    const lng = radiansToDegrees(longitude2);\r\n    const lat = radiansToDegrees(latitude2);\r\n\r\n    return point([lng, lat], options.properties);\r\n}\r\n","import destination from '../destination';\r\nimport { polygon, checkIfOptionsExist } from '../helpers';\r\n\r\n/**\r\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\r\n *\r\n * @name circle\r\n * @param {Feature<Point>|number[]} center center point\r\n * @param {number} radius radius of the circle\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.steps=64] number of steps\r\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\r\n * @param {Object} [options.properties={}] properties\r\n * @returns {Feature<Polygon>} circle polygon\r\n * @example\r\n * var center = [-75.343, 39.984];\r\n * var radius = 5;\r\n * var options = {steps, units, properties{foo, radius, options);\r\n *\r\n * //addToMap\r\n * var addToMap = [turf.point(center), circle]\r\n */\r\nfunction circle(center, radius, options) {\r\n    options = checkIfOptionsExist(options);\r\n    // default params\r\n    const steps = options.steps || 64;\r\n    const properties = options.properties ? options.properties : (!Array.isArray(center) && center.type === 'Feature' && center.properties) ? center.properties : {};\r\n\r\n    // main\r\n    const coordinates = [];\r\n    for (let i = 0; i < steps; i++) {\r\n        coordinates.push(destination(center, radius, i * -360 / steps, options).geometry.coordinates);\r\n    }\r\n    coordinates.push(coordinates[0]);\r\n\r\n    return polygon([coordinates], properties);\r\n}\r\n\r\nexport default circle;\r\n","import { feature, point, lineString, isObject } from '../helpers';\r\n\r\n/**\r\n * Callback for coordEach\r\n *\r\n * @callback coordEachCallback\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nexport function coordEach(geojson, callback, excludeWrapCoord) {\r\n    // Handles null Geometry -- Skips this GeoJSON\r\n    if (geojson === null) return;\r\n    var j, k, l, geometry, stopG, coords,\r\n        geometryMaybeCollection,\r\n        wrapShrink = 0,\r\n        coordIndex = 0,\r\n        isGeometryCollection,\r\n        type = geojson.type,\r\n        isFeatureCollection = type === 'FeatureCollection',\r\n        isFeature = type === 'Feature',\r\n        stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n    // This logic may look a little weird. The reason why it is that way\r\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n    // of objects at its root: FeatureCollection, Features, Geometries.\r\n    // This function has the responsibility of handling all of them, and that\r\n    // means that some of the `for` loops you see below actually just don't apply\r\n    // to certain inputs. For instance, if you give this just a\r\n    // Point geometry, then both loops are short-circuited and all we do\r\n    // is gradually rename the input until it's called 'geometry'.\r\n    //\r\n    // This also aims to allocate as few resources as possible: just a\r\n    // few numbers and booleans, rather than any temporary arrays as would\r\n    // be required with the normalization approach.\r\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\r\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\r\n            (isFeature ? geojson.geometry : geojson));\r\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\r\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\r\n\r\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\r\n            var multiFeatureIndex = 0;\r\n            var geometryIndex = 0;\r\n            geometry = isGeometryCollection ?\r\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\r\n\r\n            // Handles null Geometry -- Skips this geometry\r\n            if (geometry === null) continue;\r\n            coords = geometry.coordinates;\r\n            var geomType = geometry.type;\r\n\r\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\r\n\r\n            switch (geomType) {\r\n            case null:\r\n                break;\r\n            case 'Point':\r\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                coordIndex++;\r\n                multiFeatureIndex++;\r\n                break;\r\n            case 'LineString':\r\n            case 'MultiPoint':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                    coordIndex++;\r\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\r\n                }\r\n                if (geomType === 'LineString') multiFeatureIndex++;\r\n                break;\r\n            case 'Polygon':\r\n            case 'MultiLineString':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\r\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                        coordIndex++;\r\n                    }\r\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\r\n                    if (geomType === 'Polygon') geometryIndex++;\r\n                }\r\n                if (geomType === 'Polygon') multiFeatureIndex++;\r\n                break;\r\n            case 'MultiPolygon':\r\n                for (j = 0; j < coords.length; j++) {\r\n                    geometryIndex = 0;\r\n                    for (k = 0; k < coords[j].length; k++) {\r\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\r\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n                            coordIndex++;\r\n                        }\r\n                        geometryIndex++;\r\n                    }\r\n                    multiFeatureIndex++;\r\n                }\r\n                break;\r\n            case 'GeometryCollection':\r\n                for (j = 0; j < geometry.geometries.length; j++)\r\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\r\n                break;\r\n            default:\r\n                throw new Error('Unknown Geometry Type');\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for coordReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback coordReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\r\n *\r\n * @name coordReduce\r\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentCoord;\r\n * });\r\n */\r\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\r\n    var previousValue = initialValue;\r\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\r\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\r\n    }, excludeWrapCoord);\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for propEach\r\n *\r\n * @callback propEachCallback\r\n * @param {Object} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name propEach\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propEach(features, function (currentProperties, featureIndex) {\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n * });\r\n */\r\nexport function propEach(geojson, callback) {\r\n    var i;\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        for (i = 0; i < geojson.features.length; i++) {\r\n            if (callback(geojson.features[i].properties, i) === false) break;\r\n        }\r\n        break;\r\n    case 'Feature':\r\n        callback(geojson.properties, 0);\r\n        break;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Callback for propReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback propReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {*} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce properties in any GeoJSON object into a single value,\r\n * similar to how Array.reduce works. However, in this case we lazily run\r\n * the reduction, so an array of all properties is unnecessary.\r\n *\r\n * @name propReduce\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n *   return currentProperties\r\n * });\r\n */\r\nexport function propReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    propEach(geojson, function (currentProperties, featureIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\r\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for featureEach\r\n *\r\n * @callback featureEachCallback\r\n * @param {Feature<any>} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name featureEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.featureEach(features, function (currentFeature, featureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n * });\r\n */\r\nexport function featureEach(geojson, callback) {\r\n    if (geojson.type === 'Feature') {\r\n        callback(geojson, 0);\r\n    } else if (geojson.type === 'FeatureCollection') {\r\n        for (var i = 0; i < geojson.features.length; i++) {\r\n            if (callback(geojson.features[i], i) === false) break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for featureReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback featureReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name featureReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nexport function featureReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    featureEach(geojson, function (currentFeature, featureIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\r\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Get all coordinates from any GeoJSON object.\r\n *\r\n * @name coordAll\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @returns {Array<Array<number>>} coordinate position array\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * var coords = turf.coordAll(features);\r\n * //= [[26, 37], [36, 53]]\r\n */\r\nexport function coordAll(geojson) {\r\n    var coords = [];\r\n    coordEach(geojson, function (coord) {\r\n        coords.push(coord);\r\n    });\r\n    return coords;\r\n}\r\n\r\n/**\r\n * Callback for geomEach\r\n *\r\n * @callback geomEachCallback\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name geomEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n * });\r\n */\r\nexport function geomEach(geojson, callback) {\r\n    var i, j, g, geometry, stopG,\r\n        geometryMaybeCollection,\r\n        isGeometryCollection,\r\n        featureProperties,\r\n        featureBBox,\r\n        featureId,\r\n        featureIndex = 0,\r\n        isFeatureCollection = geojson.type === 'FeatureCollection',\r\n        isFeature = geojson.type === 'Feature',\r\n        stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n    // This logic may look a little weird. The reason why it is that way\r\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n    // of objects at its root: FeatureCollection, Features, Geometries.\r\n    // This function has the responsibility of handling all of them, and that\r\n    // means that some of the `for` loops you see below actually just don't apply\r\n    // to certain inputs. For instance, if you give this just a\r\n    // Point geometry, then both loops are short-circuited and all we do\r\n    // is gradually rename the input until it's called 'geometry'.\r\n    //\r\n    // This also aims to allocate as few resources as possible: just a\r\n    // few numbers and booleans, rather than any temporary arrays as would\r\n    // be required with the normalization approach.\r\n    for (i = 0; i < stop; i++) {\r\n\r\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\r\n            (isFeature ? geojson.geometry : geojson));\r\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\r\n            (isFeature ? geojson.properties : {}));\r\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\r\n            (isFeature ? geojson.bbox : undefined));\r\n        featureId = (isFeatureCollection ? geojson.features[i].id :\r\n            (isFeature ? geojson.id : undefined));\r\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\r\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\r\n\r\n        for (g = 0; g < stopG; g++) {\r\n            geometry = isGeometryCollection ?\r\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\r\n\r\n            // Handle null Geometry\r\n            if (geometry === null) {\r\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                continue;\r\n            }\r\n            switch (geometry.type) {\r\n            case 'Point':\r\n            case 'LineString':\r\n            case 'MultiPoint':\r\n            case 'Polygon':\r\n            case 'MultiLineString':\r\n            case 'MultiPolygon': {\r\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                break;\r\n            }\r\n            case 'GeometryCollection': {\r\n                for (j = 0; j < geometry.geometries.length; j++) {\r\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\r\n                }\r\n                break;\r\n            }\r\n            default:\r\n                throw new Error('Unknown Geometry Type');\r\n            }\r\n        }\r\n        // Only increase `featureIndex` per each feature\r\n        featureIndex++;\r\n    }\r\n}\r\n\r\n/**\r\n * Callback for geomReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback geomReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name geomReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=previousValue\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n *   return currentGeometry\r\n * });\r\n */\r\nexport function geomReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\r\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for flattenEach\r\n *\r\n * @callback flattenEachCallback\r\n * @param {Feature} currentFeature The current flattened feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over flattened features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name flattenEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n * });\r\n */\r\nexport function flattenEach(geojson, callback) {\r\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\r\n        // Callback for single geometry\r\n        var type = (geometry === null) ? null : geometry.type;\r\n        switch (type) {\r\n        case null:\r\n        case 'Point':\r\n        case 'LineString':\r\n        case 'Polygon':\r\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\r\n            return;\r\n        }\r\n\r\n        var geomType;\r\n\r\n        // Callback for multi-geometry\r\n        switch (type) {\r\n        case 'MultiPoint':\r\n            geomType = 'Point';\r\n            break;\r\n        case 'MultiLineString':\r\n            geomType = 'LineString';\r\n            break;\r\n        case 'MultiPolygon':\r\n            geomType = 'Polygon';\r\n            break;\r\n        }\r\n\r\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\r\n            var coordinate = geometry.coordinates[multiFeatureIndex];\r\n            var geom = {\r\n                type: geomType,\r\n                coordinates: coordinate\r\n            };\r\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for flattenReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback flattenReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name flattenReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nexport function flattenReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\r\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for segmentEach\r\n *\r\n * @callback segmentEachCallback\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //=currentSegment\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   //=segmentIndex\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var total = 0;\r\n * turf.segmentEach(polygon, function () {\r\n *     total++;\r\n * });\r\n */\r\nexport function segmentEach(geojson, callback) {\r\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n        var segmentIndex = 0;\r\n\r\n        // Exclude null Geometries\r\n        if (!feature.geometry) return;\r\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n        var type = feature.geometry.type;\r\n        if (type === 'Point' || type === 'MultiPoint') return;\r\n\r\n        // Generate 2-vertex line segments\r\n        var previousCoords;\r\n        var previousFeatureIndex = 0;\r\n        var previousMultiIndex = 0;\r\n        var prevGeomIndex = 0;\r\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\r\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\r\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\r\n                previousCoords = currentCoord;\r\n                previousFeatureIndex = featureIndex;\r\n                previousMultiIndex = multiPartIndexCoord;\r\n                prevGeomIndex = geometryIndex;\r\n                segmentIndex = 0;\r\n                return;\r\n            }\r\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\r\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\r\n            segmentIndex++;\r\n            previousCoords = currentCoord;\r\n        }) === false) return false;\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for segmentReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback segmentReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n */\r\n\r\n/**\r\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //= previousSegment\r\n *   //= currentSegment\r\n *   //= featureIndex\r\n *   //= multiFeatureIndex\r\n *   //= geometryIndex\r\n *   //= segmentInex\r\n *   return currentSegment\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var initialValue = 0\r\n * var total = turf.segmentReduce(polygon, function (previousValue) {\r\n *     previousValue++;\r\n *     return previousValue;\r\n * }, initialValue);\r\n */\r\nexport function segmentReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    var started = false;\r\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\r\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\r\n        started = true;\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for lineEach\r\n *\r\n * @callback lineEachCallback\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\r\n * similar to Array.forEach.\r\n *\r\n * @name lineEach\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *   [[26, 37], [35, 45]],\r\n *   [[36, 53], [38, 50], [41, 55]]\r\n * ]);\r\n *\r\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nexport function lineEach(geojson, callback) {\r\n    // validation\r\n    if (!geojson) throw new Error('geojson is required');\r\n\r\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n        if (feature.geometry === null) return;\r\n        var type = feature.geometry.type;\r\n        var coords = feature.geometry.coordinates;\r\n        switch (type) {\r\n        case 'LineString':\r\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\r\n            break;\r\n        case 'Polygon':\r\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\r\n                if (callback(lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\r\n            }\r\n            break;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Callback for lineReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback lineReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name lineReduce\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var multiPoly = turf.multiPolygon([\r\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\r\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\r\n * ]);\r\n *\r\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentLine\r\n * });\r\n */\r\nexport function lineReduce(geojson, callback, initialValue) {\r\n    var previousValue = initialValue;\r\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\r\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\r\n    });\r\n    return previousValue;\r\n}\r\n\r\n/**\r\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `../meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n * Point & MultiPoint will always return null.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.segmentIndex=0] Segment Index\r\n * @param {Object} [options.properties={}] Translate Properties to output LineString\r\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\r\n * @param {number|string} [options.id={}] Translate Id to output LineString\r\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findSegment(multiLine);\r\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\r\n *\r\n * // First Segment of 2nd Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\r\n *\r\n * // Last Segment of Last Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\r\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\r\n */\r\nexport function findSegment(geojson, options) {\r\n    // Optional Parameters\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    var featureIndex = options.featureIndex || 0;\r\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n    var geometryIndex = options.geometryIndex || 0;\r\n    var segmentIndex = options.segmentIndex || 0;\r\n\r\n    // Find FeatureIndex\r\n    var properties = options.properties;\r\n    var geometry;\r\n\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\r\n        properties = properties || geojson.features[featureIndex].properties;\r\n        geometry = geojson.features[featureIndex].geometry;\r\n        break;\r\n    case 'Feature':\r\n        properties = properties || geojson.properties;\r\n        geometry = geojson.geometry;\r\n        break;\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n    case 'Polygon':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n        geometry = geojson;\r\n        break;\r\n    default:\r\n        throw new Error('geojson is invalid');\r\n    }\r\n\r\n    // Find SegmentIndex\r\n    if (geometry === null) return null;\r\n    var coords = geometry.coordinates;\r\n    switch (geometry.type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\r\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\r\n    case 'Polygon':\r\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\r\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\r\n    case 'MultiLineString':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\r\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\r\n    case 'MultiPolygon':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\r\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\r\n    }\r\n    throw new Error('geojson is invalid');\r\n}\r\n\r\n/**\r\n * Finds a particular Point from a GeoJSON using `../meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.coordIndex=0] Coord Index\r\n * @param {Object} [options.properties={}] Translate Properties to output Point\r\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\r\n * @param {number|string} [options.id={}] Translate Id to output Point\r\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findPoint(multiLine);\r\n * // => Feature<Point<[10, 10]>>\r\n *\r\n * // First Segment of the 2nd Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<Point<[-10, -10]>>\r\n *\r\n * // Last Segment of last Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\r\n * // => Feature<Point<[-30, -40]>>\r\n */\r\nexport function findPoint(geojson, options) {\r\n    // Optional Parameters\r\n    options = options || {};\r\n    if (!isObject(options)) throw new Error('options is invalid');\r\n    var featureIndex = options.featureIndex || 0;\r\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n    var geometryIndex = options.geometryIndex || 0;\r\n    var coordIndex = options.coordIndex || 0;\r\n\r\n    // Find FeatureIndex\r\n    var properties = options.properties;\r\n    var geometry;\r\n\r\n    switch (geojson.type) {\r\n    case 'FeatureCollection':\r\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\r\n        properties = properties || geojson.features[featureIndex].properties;\r\n        geometry = geojson.features[featureIndex].geometry;\r\n        break;\r\n    case 'Feature':\r\n        properties = properties || geojson.properties;\r\n        geometry = geojson.geometry;\r\n        break;\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n        return null;\r\n    case 'LineString':\r\n    case 'Polygon':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n        geometry = geojson;\r\n        break;\r\n    default:\r\n        throw new Error('geojson is invalid');\r\n    }\r\n\r\n    // Find Coord Index\r\n    if (geometry === null) return null;\r\n    var coords = geometry.coordinates;\r\n    switch (geometry.type) {\r\n    case 'Point':\r\n        return point(coords, properties, options);\r\n    case 'MultiPoint':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        return point(coords[multiFeatureIndex], properties, options);\r\n    case 'LineString':\r\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\r\n        return point(coords[coordIndex], properties, options);\r\n    case 'Polygon':\r\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\r\n        return point(coords[geometryIndex][coordIndex], properties, options);\r\n    case 'MultiLineString':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\r\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\r\n    case 'MultiPolygon':\r\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\r\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\r\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\r\n    }\r\n    throw new Error('geojson is invalid');\r\n}\r\n","import circle from 'turf/src/circle';\nimport union from 'turf/src/union/';\nimport difference from 'turf/src/difference';\n\n\nlet turf = {\n\tcircle: circle,\n\tunion: union,\n\tdifference: difference\n};\n\nexport default turf;","import * as polyClipping from 'polygon-clipping';\r\nimport { multiPolygon } from '../helpers';\r\nimport { geomEach } from '../meta';\r\n\r\n/**\r\n * Takes two or more {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.\r\n *\r\n * @name union\r\n * @param {Feature<Polygon|MultiPolygon>} fc a FeatureCollection containting polygons or multipolygons to union\r\n * @returns {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature\r\n * @example\r\n * var poly1 = turf.polygon([[\r\n *     [-82.574787, 35.594087],\r\n *     [-82.574787, 35.615581],\r\n *     [-82.545261, 35.615581],\r\n *     [-82.545261, 35.594087],\r\n *     [-82.574787, 35.594087]\r\n * ]], {\"fill\": \"#0f0\"});\r\n * var poly2 = turf.polygon([[\r\n *     [-82.560024, 35.585153],\r\n *     [-82.560024, 35.602602],\r\n *     [-82.52964, 35.602602],\r\n *     [-82.52964, 35.585153],\r\n *     [-82.560024, 35.585153]\r\n * ]], {\"fill\": \"#00f\"});\r\n *\r\n * var union = turf.union(poly1, poly2);\r\n *\r\n * //addToMap\r\n * var addToMap = [poly1, poly2, union];\r\n */\r\nfunction union(fc) {\r\n\r\n    const args = [];\r\n    geomEach(fc, function (geom) {\r\n        if (geom.type === 'Polygon') args.push(geom.coordinates);\r\n        else geom.coordinates.forEach(function (contour) {\r\n            args.push(contour);\r\n        });\r\n    });\r\n    var unioned = polyClipping.union(args);\r\n    if (unioned.length === 0) return null;\r\n    else return multiPolygon(unioned);\r\n}\r\n\r\nexport default union;\r\n","import * as polyClipping from 'polygon-clipping';\r\nimport {  multiPolygon } from '../helpers';\r\nimport { getGeom } from '../invariant';\r\n\r\n/**\r\n * Finds the difference between two {@link Polygon|polygons} by clipping the second polygon from the first.\r\n *\r\n * @name difference\r\n * @param {Feature<Polygon|MultiPolygon>} polygon1 input Polygon feature\r\n * @param {Feature<Polygon|MultiPolygon>} polygon2 Polygon feature to difference from polygon1\r\n * @returns {Feature<Polygon|MultiPolygon>|null} a Polygon or MultiPolygon feature showing the area of `polygon1` excluding the area of `polygon2` (if empty returns `null`)\r\n * @example\r\n * var polygon1 = turf.polygon([[\r\n *   [128, -26],\r\n *   [141, -26],\r\n *   [141, -21],\r\n *   [128, -21],\r\n *   [128, -26]\r\n * ]], {\r\n *   \"fill\": \"#F00\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n * var polygon2 = turf.polygon([[\r\n *   [126, -28],\r\n *   [140, -28],\r\n *   [140, -20],\r\n *   [126, -20],\r\n *   [126, -28]\r\n * ]], {\r\n *   \"fill\": \"#00F\",\r\n *   \"fill-opacity\": 0.1\r\n * });\r\n *\r\n * var difference = turf.difference(polygon1, polygon2);\r\n *\r\n * //addToMap\r\n * var addToMap = [polygon1, polygon2, difference];\r\n */\r\nfunction difference(polygon1, polygon2) {\r\n    var geom1 = getGeom(polygon1);\r\n    var geom2 = getGeom(polygon2);\r\n    var properties = polygon1.properties || {};\r\n    var differenced = polyClipping.difference(geom1.coordinates, geom2.coordinates);\r\n    if (differenced.length === 0) return null;\r\n    return multiPolygon(differenced, properties);\r\n}\r\n\r\nexport default difference;\r\n","//import L from 'leaflet';\nimport turf from './myTurf.js';\nimport './PaintPolygon.css';\n\n\"use strict\";\n\n\nconst PaintPolygon = L.Control.extend({\n    options: {\n        position: 'topright',\n        radius: 30,\n        minRadius: 10,\n        maxRadius: 50,\n        layerOptions: {\n        },\n        drawOptions: {\n            weight: 1\n        },\n        eraseOptions: {\n            color: '#ff324a',\n            weight: 1\n        },\n        menu: {\n            drawErase: true,\n            size: true,\n            eraseAll: true\n        },\n    },\n\n    _latlng: [0, 0],\n    _metersPerPixel: {},\n\n    onAdd: function(map) {\n        this._map = map;\n        this.setRadius(this.options.radius);\n\n        if (this.options.menu === false) {\n            return L.DomUtil.create('div');\n        }\n\n        this._container = L.DomUtil.create('div', 'leaflet-control-paintpolygon leaflet-bar leaflet-control');\n        this._createMenu();\n\n        return this._container;\n    },\n\n    onRemove: function() {\n        this._map.off('mousemove', this._onMouseMove, this);\n    },\n\n    setRadius: function(radius) {\n        if (radius !== undefined) {\n            if (radius < this.options.minRadius) {\n                this._radius = this.options.minRadius;\n            } else if (radius > this.options.maxRadius) {\n                this._radius = this.options.maxRadius;\n            } else {\n                this._radius = radius;\n            }\n        }\n        if (this._circle) {\n            this._circle.setRadius(this._radius);\n        }\n    },\n    startDraw: function() {\n        this.stop();\n        this._action = 'draw';\n        this._addMouseListener();\n        this._circle = L.circleMarker(this._latlng, this.options.drawOptions).setRadius(this._radius).addTo(this._map);\n    },\n    startErase: function() {\n        this.stop();\n        this._action = 'erase';\n        this._addMouseListener();\n        this._circle = L.circleMarker(this._latlng, this.options.eraseOptions).setRadius(this._radius).addTo(this._map);\n    },\n    stop: function() {\n        this._action = null;\n        if (this._circle) {\n            this._circle.remove();\n        }\n        this._removeMouseListener();\n    },\n    getLayer: function() {\n        return this._layer;\n    },\n    setData: function(data) {\n        this._data = data;\n        if (this._layer !== undefined) {\n            this._layer.remove();\n        }\n        this._layer = L.geoJSON(this._data, this.options.layerOptions).addTo(this._map);\n    },\n    getData: function() {\n        return this._data;\n    },\n    eraseAll: function() {\n        this.setData();\n    },\n\n    /////////////////////////\n    // Menu creation and click callback\n    _createMenu: function() {\n        if (this.options.menu.drawErase !== false) {\n            this._iconDraw = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-brush', this._container);\n            this._iconErase = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-eraser', this._container);\n            L.DomEvent.on(this._iconDraw, 'click mousedown', this._clickDraw, this);\n            L.DomEvent.on(this._iconErase, 'click mousedown', this._clickErase, this);\n        }\n\n        if (this.options.menu.size !== false) {\n            this._iconSize = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-size', this._container);\n\n            this._menu = L.DomUtil.create('div', 'leaflet-bar leaflet-control-paintpolygon-menu', this._container);\n            L.DomEvent.disableClickPropagation(this._menu);\n\n            var menuContent = L.DomUtil.create('div', 'leaflet-control-paintpolygon-menu-content', this._menu);\n            var cursor = L.DomUtil.create('input', '', menuContent);\n            cursor.type = \"range\";\n            cursor.value = this._radius;\n            cursor.min = this.options.minRadius;\n            cursor.max = this.options.maxRadius;\n\n            L.DomEvent.on(cursor, 'input change', this._cursorMove, this);\n            L.DomEvent.on(this._iconSize, 'click mousedown', this._clickSize, this);\n        }\n\n        if (this.options.menu.eraseAll !== false) {\n            this._iconEraseAll = L.DomUtil.create('a', 'leaflet-control-paintpolygon-icon leaflet-control-paintpolygon-icon-trash', this._container);\n            L.DomEvent.on(this._iconEraseAll, 'click mousedown', this._clickEraseAll, this);\n        }\n    },\n\n    _clickDraw: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        this._resetMenu();\n        if (this._action == 'draw') {\n            this.stop();\n        } else {\n            this.startDraw();\n            this._activeIconStyle(this._iconDraw);\n        }\n    },\n    _clickErase: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        this._resetMenu();\n        if (this._action == 'erase') {\n            this.stop();\n        } else {\n            this.startErase();\n            this._activeIconStyle(this._iconErase);\n        }\n    },\n    _clickSize: function(evt) {\n        if (evt.type == 'mousedown') {\n            L.DomEvent.stop(evt);\n            return;\n        }\n        if (L.DomUtil.hasClass(this._menu, 'leaflet-control-paintpolygon-menu-open')) {\n            this._closeMenu();\n        } else {\n            this._openMenu();\n        }\n    },\n    _clickEraseAll: function(evt) {\n        this.eraseAll();\n    },\n    _resetMenu: function() {\n        L.DomUtil.removeClass(this._iconDraw, \"leaflet-control-paintpolygon-icon-active\");\n        L.DomUtil.removeClass(this._iconErase, \"leaflet-control-paintpolygon-icon-active\");\n    },\n    _activeIconStyle: function(icon) {\n        L.DomUtil.addClass(icon, \"leaflet-control-paintpolygon-icon-active\");\n    },\n    _openMenu: function() {\n        L.DomUtil.addClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\n    },\n    _closeMenu: function() {\n        L.DomUtil.removeClass(this._menu, \"leaflet-control-paintpolygon-menu-open\");\n    },\n    _cursorMove: function(evt) {\n        this.setRadius(evt.target.valueAsNumber);\n    },\n    /////////////////\n\n\n\n    ////////////////\n    // Map events\n    _addMouseListener: function() {\n        this._map.on('mousemove', this._onMouseMove, this);\n        this._map.on('mousedown', this._onMouseDown, this);\n        this._map.on('mouseup', this._onMouseUp, this);\n    },\n    _removeMouseListener: function() {\n        this._map.off('mousemove', this._onMouseMove, this);\n        this._map.off('mousedown', this._onMouseDown, this);\n        this._map.off('mouseup', this._onMouseUp, this);\n    },\n    _onMouseDown: function(evt) {\n        this._map.dragging.disable();\n        this._mousedown = true;\n        this._onMouseMove(evt);\n    },\n    _onMouseUp: function(evt) {\n        this._map.dragging.enable();\n        this._mousedown = false;\n    },\n    _onMouseMove: function(evt) {\n        this._setLatLng(evt.latlng);\n        if (this._mousedown === true) {\n            this._stackEvt(evt.latlng, this._map.getZoom(), this._radius, this._action);\n        }\n    },\n    ////////////////\n\n    _setLatLng: function(latlng) {\n        if (latlng !== undefined) {\n            this._latlng = latlng;\n        }\n        if (this._circle) {\n            this._circle.setLatLng(this._latlng);\n        }\n    },\n\n    _latLngAsGeoJSON: function(latlng) {\n        return {\n            type: \"Point\",\n            coordinates: [\n                latlng.lng,\n                latlng.lat\n            ]\n        };\n    },\n\n    _getCircleAsPolygon: function(latlng, zoom, radius) {\n        var lat = latlng.lat;\n\n        if (this._metersPerPixel[zoom] === undefined){\n            this._metersPerPixel[zoom] = 40075016.686 * Math.abs(Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom + 8);\n        }\n        return turf.circle(this._latLngAsGeoJSON(latlng), this._metersPerPixel[zoom] * radius / 1000, {\n            //steps: 128\n        });\n    },\n\n    _draw: function(latlng, zoom, radius) {\n        if (this._data === undefined || this._data === null) {\n            this.setData(this._getCircleAsPolygon(latlng, zoom, radius));\n        } else {\n            let fc = {\n                type: \"FeatureCollection\",\n                features:[this._data, this._getCircleAsPolygon(latlng, zoom, radius)]\n            };\n            this.setData(turf.union(fc));\n        }\n    },\n    _erase: function(latlng, zoom, radius) {\n        if (this._data === undefined || this._data === null) {\n            return;\n        } else {\n            this.setData(turf.difference(this._data, this._getCircleAsPolygon(latlng, zoom, radius)));\n        }\n    },\n\n    _stackEvt: function(latlng, zoom, radius, action) {\n        if (this._stack === undefined){\n            this._stack = new Array();\n        }\n\n        this._stack.push({latlng: latlng, zoom: zoom, radius: radius, action: action});\n        this._processStack();\n    },\n\n    _processStack: function() {\n        if (this._processingStack === true || this._stack.length == 0){\n            return;\n        }\n        this._processingStack = true;\n\n        var evt = this._stack.shift();\n        if (evt.action == \"draw\"){\n            this._draw(evt.latlng, evt.zoom, evt.radius);\n        } else if (evt.action == \"erase\") {\n            this._erase(evt.latlng, evt.zoom, evt.radius);\n        }\n\n        this._processingStack = false;\n        this._processStack();\n    }\n \n});\n\n\nL.Control.PaintPolygon = PaintPolygon;\nL.control.paintPolygon = options => new L.Control.PaintPolygon(options);\n\n\nexport default PaintPolygon;\n"],"sourceRoot":""}